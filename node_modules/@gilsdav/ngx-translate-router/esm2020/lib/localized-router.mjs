import { Router, ROUTES } from '@angular/router';
import { Compiler, NgModuleFactory, PLATFORM_ID, inject, Injectable } from '@angular/core';
import { isPlatformBrowser } from '@angular/common';
import { from, of, isObservable } from 'rxjs';
import { mergeMap, map } from 'rxjs/operators';
import { isPromise } from './util';
import { LocalizeParser } from './localize-router.parser';
import * as i0 from "@angular/core";
export class LocalizedRouter extends Router {
    constructor() {
        super();
        this.platformId = inject(PLATFORM_ID);
        this.compiler = inject(Compiler);
        this.localize = inject(LocalizeParser);
        // Custom configuration
        const isBrowser = isPlatformBrowser(this.platformId);
        // __proto__ is needed for preloaded modules be doesn't work with SSR
        // @ts-ignore
        const configLoader = isBrowser
            ? this.navigationTransitions.configLoader.__proto__
            : this.navigationTransitions.configLoader;
        configLoader.loadModuleFactoryOrRoutes = (loadChildren) => {
            return wrapIntoObservable(loadChildren()).pipe(mergeMap((t) => {
                let compiled;
                if (t instanceof NgModuleFactory || Array.isArray(t)) {
                    compiled = of(t);
                }
                else {
                    compiled = from(this.compiler.compileModuleAsync(t));
                }
                return compiled.pipe(map(factory => {
                    if (Array.isArray(factory)) {
                        return factory;
                    }
                    return {
                        moduleType: factory.moduleType,
                        create: (parentInjector) => {
                            const module = factory.create(parentInjector);
                            const getMethod = module.injector.get.bind(module.injector);
                            module.injector['get'] = (token, notFoundValue, flags) => {
                                const getResult = getMethod(token, notFoundValue, flags);
                                if (token === ROUTES) {
                                    // translate lazy routes
                                    return this.localize.initChildRoutes([].concat(...getResult));
                                }
                                else {
                                    return getResult;
                                }
                            };
                            return module;
                        }
                    };
                }));
            }));
        };
        // (this as any).navigations = (this as any).setupNavigations((this as any).transitions);
    }
}
LocalizedRouter.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: LocalizedRouter, deps: [], target: i0.ɵɵFactoryTarget.Injectable });
LocalizedRouter.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: LocalizedRouter, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: LocalizedRouter, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return []; } });
export function wrapIntoObservable(value) {
    if (isObservable(value)) {
        return value;
    }
    if (isPromise(value)) {
        // Use `Promise.resolve()` to wrap promise-like instances.
        // Required ie when a Resolver returns a AngularJS `$q` promise to correctly trigger the
        // change detection.
        return from(Promise.resolve(value));
    }
    return of(value);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibG9jYWxpemVkLXJvdXRlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3Byb2plY3RzL25neC10cmFuc2xhdGUtcm91dGVyL3NyYy9saWIvbG9jYWxpemVkLXJvdXRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsTUFBTSxFQUFnQixNQUFNLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUMvRCxPQUFPLEVBQVksUUFBUSxFQUFFLGVBQWUsRUFBRSxXQUFXLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNyRyxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUNwRCxPQUFPLEVBQUUsSUFBSSxFQUFFLEVBQUUsRUFBRSxZQUFZLEVBQWMsTUFBTSxNQUFNLENBQUM7QUFDMUQsT0FBTyxFQUFFLFFBQVEsRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUMvQyxPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sUUFBUSxDQUFDO0FBQ25DLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQzs7QUFHMUQsTUFBTSxPQUFPLGVBQWdCLFNBQVEsTUFBTTtJQU16QztRQUNFLEtBQUssRUFBRSxDQUFDO1FBTEYsZUFBVSxHQUFHLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUNqQyxhQUFRLEdBQUcsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQzVCLGFBQVEsR0FBRyxNQUFNLENBQUMsY0FBYyxDQUFDLENBQUM7UUFJeEMsdUJBQXVCO1FBQ3ZCLE1BQU0sU0FBUyxHQUFHLGlCQUFpQixDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUNyRCxxRUFBcUU7UUFDckUsYUFBYTtRQUNiLE1BQU0sWUFBWSxHQUFHLFNBQVM7WUFDNUIsQ0FBQyxDQUFFLElBQVksQ0FBQyxxQkFBcUIsQ0FBQyxZQUFZLENBQUMsU0FBUztZQUM1RCxDQUFDLENBQUUsSUFBWSxDQUFDLHFCQUFxQixDQUFDLFlBQVksQ0FBQztRQUVyRCxZQUFZLENBQUMseUJBQXlCLEdBQUcsQ0FBQyxZQUEwQixFQUFFLEVBQUU7WUFDdEUsT0FBTyxrQkFBa0IsQ0FBQyxZQUFZLEVBQUUsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFNLEVBQUUsRUFBRTtnQkFDakUsSUFBSSxRQUF1RCxDQUFDO2dCQUM1RCxJQUFJLENBQUMsWUFBWSxlQUFlLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRTtvQkFDcEQsUUFBUSxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztpQkFDbEI7cUJBQU07b0JBQ0wsUUFBUSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLGtCQUFrQixDQUFDLENBQUMsQ0FBQyxDQUFxQyxDQUFDO2lCQUMxRjtnQkFDRCxPQUFPLFFBQVEsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxFQUFFO29CQUNqQyxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLEVBQUU7d0JBQzFCLE9BQU8sT0FBTyxDQUFDO3FCQUNoQjtvQkFDRCxPQUFPO3dCQUNMLFVBQVUsRUFBRSxPQUFPLENBQUMsVUFBVTt3QkFDOUIsTUFBTSxFQUFFLENBQUMsY0FBd0IsRUFBRSxFQUFFOzRCQUNuQyxNQUFNLE1BQU0sR0FBRyxPQUFPLENBQUMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxDQUFDOzRCQUM5QyxNQUFNLFNBQVMsR0FBRyxNQUFNLENBQUMsUUFBUSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxDQUFDOzRCQUU1RCxNQUFNLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsS0FBVSxFQUFFLGFBQWtCLEVBQUUsS0FBVyxFQUFFLEVBQUU7Z0NBQ3ZFLE1BQU0sU0FBUyxHQUFHLFNBQVMsQ0FBQyxLQUFLLEVBQUUsYUFBYSxFQUFFLEtBQUssQ0FBQyxDQUFDO2dDQUV6RCxJQUFJLEtBQUssS0FBSyxNQUFNLEVBQUU7b0NBQ3BCLHdCQUF3QjtvQ0FDeEIsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLGVBQWUsQ0FBQyxFQUFFLENBQUMsTUFBTSxDQUFDLEdBQUcsU0FBUyxDQUFDLENBQUMsQ0FBQztpQ0FDL0Q7cUNBQU07b0NBQ0wsT0FBTyxTQUFTLENBQUM7aUNBQ2xCOzRCQUNILENBQUMsQ0FBQzs0QkFDRixPQUFPLE1BQU0sQ0FBQzt3QkFDaEIsQ0FBQztxQkFDRixDQUFDO2dCQUNKLENBQUMsQ0FBQyxDQUFDLENBQUM7WUFDTixDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ04sQ0FBQyxDQUFDO1FBQ0YseUZBQXlGO0lBQzNGLENBQUM7OzRHQW5EVSxlQUFlO2dIQUFmLGVBQWUsY0FESCxNQUFNOzJGQUNsQixlQUFlO2tCQUQzQixVQUFVO21CQUFDLEVBQUMsVUFBVSxFQUFFLE1BQU0sRUFBQzs7QUF3RGhDLE1BQU0sVUFBVSxrQkFBa0IsQ0FBSSxLQUEwRDtJQUM5RixJQUFJLFlBQVksQ0FBQyxLQUFLLENBQUMsRUFBRTtRQUN2QixPQUFPLEtBQUssQ0FBQztLQUNkO0lBRUQsSUFBSSxTQUFTLENBQUMsS0FBSyxDQUFDLEVBQUU7UUFDcEIsMERBQTBEO1FBQzFELHdGQUF3RjtRQUN4RixvQkFBb0I7UUFDcEIsT0FBTyxJQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0tBQ3JDO0lBRUQsT0FBTyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDbkIsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJvdXRlciwgTG9hZENoaWxkcmVuLCBST1VURVMgfSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xuaW1wb3J0IHsgSW5qZWN0b3IsIENvbXBpbGVyLCBOZ01vZHVsZUZhY3RvcnksIFBMQVRGT1JNX0lELCBpbmplY3QsIEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGlzUGxhdGZvcm1Ccm93c2VyIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IGZyb20sIG9mLCBpc09ic2VydmFibGUsIE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IG1lcmdlTWFwLCBtYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBpc1Byb21pc2UgfSBmcm9tICcuL3V0aWwnO1xuaW1wb3J0IHsgTG9jYWxpemVQYXJzZXIgfSBmcm9tICcuL2xvY2FsaXplLXJvdXRlci5wYXJzZXInO1xuXG5ASW5qZWN0YWJsZSh7cHJvdmlkZWRJbjogJ3Jvb3QnfSlcbmV4cG9ydCBjbGFzcyBMb2NhbGl6ZWRSb3V0ZXIgZXh0ZW5kcyBSb3V0ZXIge1xuXG4gIHByaXZhdGUgcGxhdGZvcm1JZCA9IGluamVjdChQTEFURk9STV9JRCk7XG4gIHByaXZhdGUgY29tcGlsZXIgPSBpbmplY3QoQ29tcGlsZXIpO1xuICBwcml2YXRlIGxvY2FsaXplID0gaW5qZWN0KExvY2FsaXplUGFyc2VyKTtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIC8vIEN1c3RvbSBjb25maWd1cmF0aW9uXG4gICAgY29uc3QgaXNCcm93c2VyID0gaXNQbGF0Zm9ybUJyb3dzZXIodGhpcy5wbGF0Zm9ybUlkKTtcbiAgICAvLyBfX3Byb3RvX18gaXMgbmVlZGVkIGZvciBwcmVsb2FkZWQgbW9kdWxlcyBiZSBkb2Vzbid0IHdvcmsgd2l0aCBTU1JcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3QgY29uZmlnTG9hZGVyID0gaXNCcm93c2VyXG4gICAgICA/ICh0aGlzIGFzIGFueSkubmF2aWdhdGlvblRyYW5zaXRpb25zLmNvbmZpZ0xvYWRlci5fX3Byb3RvX19cbiAgICAgIDogKHRoaXMgYXMgYW55KS5uYXZpZ2F0aW9uVHJhbnNpdGlvbnMuY29uZmlnTG9hZGVyO1xuXG4gICAgY29uZmlnTG9hZGVyLmxvYWRNb2R1bGVGYWN0b3J5T3JSb3V0ZXMgPSAobG9hZENoaWxkcmVuOiBMb2FkQ2hpbGRyZW4pID0+IHtcbiAgICAgIHJldHVybiB3cmFwSW50b09ic2VydmFibGUobG9hZENoaWxkcmVuKCkpLnBpcGUobWVyZ2VNYXAoKHQ6IGFueSkgPT4ge1xuICAgICAgICBsZXQgY29tcGlsZWQ6IE9ic2VydmFibGU8TmdNb2R1bGVGYWN0b3J5PGFueT4gfCBBcnJheTxhbnk+PjtcbiAgICAgICAgaWYgKHQgaW5zdGFuY2VvZiBOZ01vZHVsZUZhY3RvcnkgfHwgQXJyYXkuaXNBcnJheSh0KSkge1xuICAgICAgICAgIGNvbXBpbGVkID0gb2YodCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29tcGlsZWQgPSBmcm9tKHRoaXMuY29tcGlsZXIuY29tcGlsZU1vZHVsZUFzeW5jKHQpKSBhcyBPYnNlcnZhYmxlPE5nTW9kdWxlRmFjdG9yeTxhbnk+PjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tcGlsZWQucGlwZShtYXAoZmFjdG9yeSA9PiB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZmFjdG9yeSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWN0b3J5O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbW9kdWxlVHlwZTogZmFjdG9yeS5tb2R1bGVUeXBlLFxuICAgICAgICAgICAgY3JlYXRlOiAocGFyZW50SW5qZWN0b3I6IEluamVjdG9yKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IG1vZHVsZSA9IGZhY3RvcnkuY3JlYXRlKHBhcmVudEluamVjdG9yKTtcbiAgICAgICAgICAgICAgY29uc3QgZ2V0TWV0aG9kID0gbW9kdWxlLmluamVjdG9yLmdldC5iaW5kKG1vZHVsZS5pbmplY3Rvcik7XG5cbiAgICAgICAgICAgICAgbW9kdWxlLmluamVjdG9yWydnZXQnXSA9ICh0b2tlbjogYW55LCBub3RGb3VuZFZhbHVlOiBhbnksIGZsYWdzPzogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZ2V0UmVzdWx0ID0gZ2V0TWV0aG9kKHRva2VuLCBub3RGb3VuZFZhbHVlLCBmbGFncyk7XG5cbiAgICAgICAgICAgICAgICBpZiAodG9rZW4gPT09IFJPVVRFUykge1xuICAgICAgICAgICAgICAgICAgLy8gdHJhbnNsYXRlIGxhenkgcm91dGVzXG4gICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGl6ZS5pbml0Q2hpbGRSb3V0ZXMoW10uY29uY2F0KC4uLmdldFJlc3VsdCkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0UmVzdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgcmV0dXJuIG1vZHVsZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICB9KSk7XG4gICAgICB9KSk7XG4gICAgfTtcbiAgICAvLyAodGhpcyBhcyBhbnkpLm5hdmlnYXRpb25zID0gKHRoaXMgYXMgYW55KS5zZXR1cE5hdmlnYXRpb25zKCh0aGlzIGFzIGFueSkudHJhbnNpdGlvbnMpO1xuICB9XG59XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHdyYXBJbnRvT2JzZXJ2YWJsZTxUPih2YWx1ZTogVCB8IE5nTW9kdWxlRmFjdG9yeTxUPiB8IFByb21pc2U8VD4gfCBPYnNlcnZhYmxlPFQ+KSB7XG4gIGlmIChpc09ic2VydmFibGUodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgaWYgKGlzUHJvbWlzZSh2YWx1ZSkpIHtcbiAgICAvLyBVc2UgYFByb21pc2UucmVzb2x2ZSgpYCB0byB3cmFwIHByb21pc2UtbGlrZSBpbnN0YW5jZXMuXG4gICAgLy8gUmVxdWlyZWQgaWUgd2hlbiBhIFJlc29sdmVyIHJldHVybnMgYSBBbmd1bGFySlMgYCRxYCBwcm9taXNlIHRvIGNvcnJlY3RseSB0cmlnZ2VyIHRoZVxuICAgIC8vIGNoYW5nZSBkZXRlY3Rpb24uXG4gICAgcmV0dXJuIGZyb20oUHJvbWlzZS5yZXNvbHZlKHZhbHVlKSk7XG4gIH1cblxuICByZXR1cm4gb2YodmFsdWUpO1xufVxuIl19