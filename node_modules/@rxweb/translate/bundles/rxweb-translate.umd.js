(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/common'), require('@angular/core'), require('rxjs'), require('rxjs/operators'), require('@angular/common/http'), require('@angular/router'), require('@angular/forms')) :
    typeof define === 'function' && define.amd ? define('@rxweb/translate', ['exports', '@angular/common', '@angular/core', 'rxjs', 'rxjs/operators', '@angular/common/http', '@angular/router', '@angular/forms'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.rxweb = global.rxweb || {}, global.rxweb.translate = {}), global.ng.common, global.ng.core, global.rxjs, global.rxjs.operators, global.ng.common.http, global.ng.router, global.ng.forms));
}(this, (function (exports, common, core, rxjs, operators, http, router, forms) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    /** @deprecated */
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    /** @deprecated */
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    function __spreadArray(to, from) {
        for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)
            to[j] = from[i];
        return to;
    }
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, state, kind, f) {
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    }
    function __classPrivateFieldSet(receiver, state, value, kind, f) {
        if (kind === "m")
            throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    }

    var MultiLingualData = new (/** @class */ (function () {
        function class_1() {
            this.translationModelData = new Array();
            this.data = {};
            this.keys = {};
            this.contentKeysByLanguage = {};
        }
        class_1.prototype.addOrUpdate = function (key, data, translationName, languageCode) {
            this.data[key] = data;
            this.keys[translationName] = true;
            if (languageCode)
                this.contentKeysByLanguage[key] = languageCode;
        };
        class_1.prototype.addOrUpdateComponent = function (key, data, instance, refMarkedId) {
            var indexOf = this.translationModelData.findIndex(function (t) { return t.instance == instance && t.key == key && t.rxRefMarkedId == refMarkedId; });
            if (indexOf != -1)
                this.translationModelData[indexOf] = { key: key, data: data, instance: instance, rxRefMarkedId: refMarkedId };
            else
                this.translationModelData.push({ key: key, data: data, instance: instance, rxRefMarkedId: refMarkedId });
        };
        class_1.prototype.getComponentPropValue = function (key, instance, refMarkedId) {
            var indexOf = this.translationModelData.findIndex(function (t) { return t.instance == instance && t.key == key && t.rxRefMarkedId == refMarkedId; });
            return indexOf != -1 ? this.translationModelData[indexOf].data : undefined;
        };
        class_1.prototype.removeComponentPropValue = function (instance, refMarkedId, keyName) {
            var e_1, _a;
            var indexOf = -1;
            if (keyName)
                indexOf = this.translationModelData.findIndex(function (t) { return t.instance == instance && t.rxRefMarkedId == refMarkedId && t.key == keyName; });
            else {
                var result = this.translationModelData.filter(function (t) { return t.instance == instance && t.rxRefMarkedId == refMarkedId; });
                try {
                    for (var result_1 = __values(result), result_1_1 = result_1.next(); !result_1_1.done; result_1_1 = result_1.next()) {
                        var data = result_1_1.value;
                        this.translationModelData.splice(this.translationModelData.indexOf(data), 1);
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (result_1_1 && !result_1_1.done && (_a = result_1.return)) _a.call(result_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
            return indexOf != -1 ? this.translationModelData.splice(indexOf, 1) : undefined;
        };
        class_1.prototype.contains = function (key, languageCode) {
            return this.data[key] ? this.contentKeysByLanguage[key] == languageCode : false;
        };
        class_1.prototype.get = function (key) {
            return this.data[key] ? this.data[key] : undefined;
        };
        class_1.prototype.clearInActives = function (config) {
            var _this = this;
            if (!config.cacheActiveLanguageObject || (!config.cacheActiveLanguageObject && !config.cacheLanguageWiseObject))
                Object.keys(this.keys).forEach(function (t) {
                    if (!_this.keys[t] && _this.data[t]) {
                        delete _this.data[t];
                    }
                });
        };
        class_1.prototype.getActiveKeys = function () {
            return Object.keys(this.keys);
        };
        class_1.prototype.remove = function (key) {
            this.keys[key] = undefined;
        };
        return class_1;
    }()));

    function isObject(value) {
        return Object.prototype.toString.call(value) === '[object Object]';
    }

    function extract(_a) {
        var _b = __read(_a, 2), start = _b[0], end = _b[1];
        var matcher = new RegExp(start + "(.*?)" + end, 'gm');
        var normalise = function (str) { return str.slice(start.length, end.length * -1); };
        return function (str) {
            return str.match(matcher).map(normalise);
        };
    }

    function getValue(key, data) {
        var e_1, _a;
        var isObjectKey = key.indexOf(".") !== -1;
        if (isObjectKey) {
            var keys = key.split('.');
            var jObject = data;
            try {
                for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
                    var column = keys_1_1.value;
                    if (jObject[column])
                        jObject = jObject[column];
                    else {
                        jObject = "";
                        break;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return jObject;
        }
        var value = data[key];
        return value == undefined ? '' : value;
    }

    var translateConfigContainer = new (/** @class */ (function () {
        function class_1() {
        }
        return class_1;
    }()))();

    function equals(o1, o2) {
        if (o1 === o2)
            return true;
        if (o1 === null || o2 === null)
            return false;
        if (o1 !== o1 && o2 !== o2)
            return true; // NaN === NaN
        var t1 = typeof o1, t2 = typeof o2, length, key, keySet;
        if (t1 == t2 && t1 == 'object') {
            if (Array.isArray(o1)) {
                if (!Array.isArray(o2))
                    return false;
                if ((length = o1.length) == o2.length) {
                    for (key = 0; key < length; key++) {
                        if (!equals(o1[key], o2[key]))
                            return false;
                    }
                    return true;
                }
            }
            else {
                if (Array.isArray(o2)) {
                    return false;
                }
                keySet = Object.create(null);
                for (key in o1) {
                    if (!equals(o1[key], o2[key])) {
                        return false;
                    }
                    keySet[key] = true;
                }
                for (key in o2) {
                    if (!(key in keySet) && typeof o2[key] !== 'undefined') {
                        return false;
                    }
                }
                return true;
            }
        }
        return false;
    }

    function getKeyName(name, languageCode, filePath) {
        if (translateConfigContainer.config && translateConfigContainer.config.cacheLanguageWiseObject && (!filePath || (filePath && name == "global")))
            return name + "_" + (languageCode || translateConfigContainer.config.languageCode);
        return name;
    }

    var PIPE_CONFIG = {
        'currency': common.CurrencyPipe,
        'date': common.DatePipe,
        'decimal': common.DecimalPipe,
        'i18nPlural': common.I18nPluralPipe,
        'i18nSelect': common.I18nSelectPipe,
        'slice': common.SlicePipe,
        'lowercase': common.LowerCasePipe,
        'uppercase': common.UpperCasePipe,
        'percent': common.PercentPipe,
        'titlecase': common.TitleCasePipe
    };

    function getInstanceValue(key, componentData, parentData) {
        var value = "";
        if (key.indexOf("'") != 0) {
            value = getValue(key, parentData);
            if (!value)
                value = getValue(key, componentData);
        }
        return value == "" ? key.replace(new RegExp(/[']/, "g"), "") : value;
    }

    function runPipe(text, componentData, parentData) {
        var pipeName = '';
        if (text.indexOf("|") !== -1) {
            var splitText = text.split("|");
            var leftText = getInstanceValue(splitText[0].trim(), componentData, parentData);
            var rightText = splitText[1].split(new RegExp(":(?=([^\"]*\"[^\"]*\")*[^\"]*$)")).filter(function (t) { return t !== undefined; }).map(function (t) { return getInstanceValue(t, componentData, parentData); });
            pipeName = rightText[0].trim();
            rightText.splice(0, 1);
            if (translateConfigContainer.injector && pipeName && PIPE_CONFIG[pipeName]) {
                var resolve = translateConfigContainer.injector.get(PIPE_CONFIG[pipeName]);
                text = resolve.transform.apply(resolve, __spreadArray([leftText], __read(rightText)));
            }
        }
        return text;
    }

    var TranslateModel = /** @class */ (function () {
        function TranslateModel(raw, componentData, modelName, parentData) {
            var _this = this;
            this.raw = raw;
            this.componentData = componentData;
            this.modelName = modelName;
            this.parentData = parentData;
            this.keyParameters = {};
            this.memoized = {};
            this.thisParameter = {};
            var data = raw;
            if (data)
                Object.keys(data).forEach(function (key) {
                    Object.defineProperty(_this, key, {
                        get: function () {
                            var text = data[key];
                            if (isObject(text)) {
                                if (!(data[key] instanceof TranslateModel)) {
                                    var pData = Object.keys(parentData).length == 0 ? data : parentData;
                                    if (!translateConfigContainer.loading)
                                        text = data[key] = new TranslateModel(data[key], componentData, modelName, pData);
                                    else
                                        return new TranslateModel(data[key], {}, modelName, pData);
                                }
                                else
                                    text = data[key];
                                return text;
                            }
                            return translateConfigContainer.loading ? "loading..." : this.transform(data, key, text);
                        },
                        enumerable: true,
                        configurable: true
                    });
                });
        }
        TranslateModel.prototype.getKeyValue = function (keyParamObject) {
            var _this = this;
            var keyValue = {};
            Object.keys(keyParamObject).forEach(function (key) {
                keyValue[key] = getValue(key, _this.componentData);
            });
            return keyValue;
        };
        TranslateModel.prototype.transform = function (data, key, text) {
            if (this.thisParameter[key])
                return this.getText(data, text, key);
            if (this.keyParameters && this.keyParameters[key] && isObject(this.keyParameters[key])) {
                if (!equals(this.keyParameters[key], this.getKeyValue(this.keyParameters[key])))
                    return this.getText(data, text, key);
                else if (this.memoized[key])
                    return this.memoized[key];
            }
            if (this.keyParameters && !this.keyParameters[key])
                return this.getText(data, text, key);
            else
                return typeof text === "function" ? text() : text;
        };
        Object.defineProperty(TranslateModel.prototype, "languageCode", {
            get: function () {
                return translateConfigContainer.config ? translateConfigContainer.config.languageCode : "en";
            },
            enumerable: false,
            configurable: true
        });
        TranslateModel.prototype.get = function (key) {
            var e_1, _a;
            var jObject;
            if (key) {
                var keys = key.split(".");
                try {
                    for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
                        var column = keys_1_1.value;
                        if (!jObject)
                            jObject = this[column];
                        else
                            jObject = jObject[column];
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
            return jObject;
        };
        TranslateModel.prototype.addOrUpdateKey = function (name, value) {
            var keyName = getKeyName(this.modelName, this.languageCode, undefined);
            var data = MultiLingualData.get(keyName);
            if (!isObject(value))
                data[name] = value;
            else if (data[name])
                data[name] = Object.assign(Object.assign({}, data[name]), value);
            else
                data[name] = value;
            MultiLingualData.addOrUpdate(keyName, data, this.languageCode);
            MultiLingualData.removeComponentPropValue(this.componentData.constructor, this.componentData["__ngContext__"].rxRefMarkedId, keyName);
        };
        TranslateModel.prototype.ngxTranslateParser = function (translations, key) {
            return translateConfigContainer.ngxTranslate["getParsedResult"](translations, key, null);
        };
        TranslateModel.prototype.getText = function (translations, text, columnKey) {
            var _this = this;
            text = translateConfigContainer.ngxTranslate ? this.ngxTranslateParser(translations, columnKey) : text;
            if (text.indexOf('this.') !== -1 || text.indexOf('{{{this') !== -1) {
                this.thisParameter[columnKey] = true;
                if (text.indexOf('{{{this') !== -1) {
                    var stringExtractor = extract(['{{{', '}}}']);
                    var keys = stringExtractor(text);
                    keys.forEach(function (t) {
                        var func = new Function("x", "return " + t);
                        var calculatedText = func.call(_this.componentData);
                        text = text.replace("{{{" + t + "}}}", calculatedText);
                    });
                }
                else {
                    var func = new Function("x", "return " + text);
                    text = func.call(this.componentData);
                }
            }
            if (text && text.indexOf("{{") != -1) {
                var stringExtractor = extract(['{{', '}}']);
                var keys = stringExtractor(text);
                keys.forEach(function (key) {
                    var value = runPipe(key, _this.componentData, _this.parentData);
                    if (key == value) {
                        value = getValue(key, _this.parentData);
                        if (!value)
                            value = getValue(key, _this.componentData);
                    }
                    if (!_this.keyParameters[columnKey])
                        _this.keyParameters[columnKey] = {};
                    _this.keyParameters[columnKey][key] = value;
                    text = text.replace("{{" + key + "}}", value);
                });
                this.memoized[columnKey] = text;
            }
            else
                this.keyParameters[columnKey] = true;
            return text;
        };
        return TranslateModel;
    }());

    var NG_CONTEXT$1 = "__ngContext__";
    var NG_ELEMENT_ID = "__NG_ELEMENT_ID__";
    var LVIEW = "_lView";
    var CD_REF_INJECTING_VIEW = "_cdRefInjectingView";
    var CONSTRUCTOR = "constructor";
    var RxChangeDetectorRef = /** @class */ (function (_super) {
        __extends(RxChangeDetectorRef, _super);
        function RxChangeDetectorRef(instance) {
            var _this = _super.call(this) || this;
            _this.instance = instance;
            return _this;
        }
        RxChangeDetectorRef.prototype.createViewRef = function () {
            if (this.instance[NG_CONTEXT$1] && this.instance[NG_CONTEXT$1].rxRefMarkedId === undefined) {
                var emulatedDom = this.instance[NG_CONTEXT$1][11];
                if (emulatedDom && emulatedDom.component && emulatedDom.component.onPush) {
                    this.viewRef = _super.prototype[CONSTRUCTOR][NG_ELEMENT_ID]();
                    this.viewRef[LVIEW] = this.viewRef[CD_REF_INJECTING_VIEW] = this.instance[NG_CONTEXT$1][14];
                }
                this.setDestroyHooks();
                this.instance[NG_CONTEXT$1].rxRefMarkedId = Math.random();
            }
            return this.viewRef;
        };
        RxChangeDetectorRef.prototype.setDestroyHooks = function () {
            var _this = this;
            var tView = this.instance[NG_CONTEXT$1][1];
            if (!tView.destroyHooks)
                tView.destroyHooks = [this.instance[NG_CONTEXT$1].length - 1, function () { MultiLingualData.removeComponentPropValue(_this.instance.constructor, _this.instance[NG_CONTEXT$1].rxRefMarkedId); }];
            else
                tView.destroyHooks.push(this.instance[NG_CONTEXT$1].length - 1, function () {
                    MultiLingualData.removeComponentPropValue(_this.instance.constructor, _this.instance[NG_CONTEXT$1].rxRefMarkedId);
                });
        };
        RxChangeDetectorRef.prototype.markForCheck = function () {
            this.viewRef.markForCheck();
        };
        RxChangeDetectorRef.prototype.detach = function () {
            throw new Error("Method not implemented.");
        };
        RxChangeDetectorRef.prototype.detectChanges = function () {
            throw new Error("Method not implemented.");
        };
        RxChangeDetectorRef.prototype.checkNoChanges = function () {
            throw new Error("Method not implemented.");
        };
        RxChangeDetectorRef.prototype.reattach = function () {
            throw new Error("Method not implemented.");
        };
        return RxChangeDetectorRef;
    }(core.ChangeDetectorRef));

    var NG_CONTEXT = "__ngContext__";
    var viewRefContainer = new (/** @class */ (function () {
        function class_1() {
            this.viewRefs = new Array();
            this.increment = 1;
        }
        class_1.prototype.create = function (instance) {
            var changeDetector = new RxChangeDetectorRef(instance);
            if (changeDetector.createViewRef())
                this.viewRefs.push(changeDetector);
            return instance[NG_CONTEXT] ? instance[NG_CONTEXT].rxRefMarkedId : 0;
        };
        class_1.prototype.markForCheck = function () {
            this.viewRefs.forEach(function (cd) {
                cd.markForCheck();
            });
        };
        class_1.prototype.destroy = function (instance) {
            if (instance[NG_CONTEXT] && instance[NG_CONTEXT].rxRefMarkedId !== undefined) {
                var indexOf = this.viewRefs.findIndex(function (t) { return t.instance[NG_CONTEXT].rxRefMarkedId == instance[NG_CONTEXT].rxRefMarkedId; });
                if (indexOf != -1)
                    this.viewRefs.splice(indexOf, 1);
            }
        };
        return class_1;
    }()))();

    function defineProperty(model, propertyName, modelName, languageCode, filePath) {
        var data = null;
        Object.defineProperty(model.prototype, propertyName, {
            get: function () {
                var keyName = getKeyName(modelName, languageCode, filePath);
                data = MultiLingualData.get(keyName);
                var refMarkedId = this["__ngContext__"] ? this["__ngContext__"].rxRefMarkedId : 0;
                var translationModelData = MultiLingualData.getComponentPropValue(keyName, this.constructor, refMarkedId);
                if ((data && !translationModelData))
                    if (!translateConfigContainer.loading) {
                        refMarkedId = viewRefContainer.create(this);
                        MultiLingualData.addOrUpdateComponent(keyName, new TranslateModel(Object.assign({}, data), this, modelName, {}), this.constructor, refMarkedId);
                    }
                    else
                        return new TranslateModel(data, {}, modelName, {});
                var value = MultiLingualData.getComponentPropValue(keyName, this.constructor, refMarkedId);
                return value === undefined ? {} : value;
            },
            enumerable: true,
            configurable: true
        });
    }

    function defineAsyncProperty(model, propertyName, config) {
        var observable = null;
        var service = null;
        var currentLanguage = null;
        Object.defineProperty(model.prototype, propertyName, {
            get: function () {
                if (!observable || currentLanguage != translateConfigContainer.config.languageCode) {
                    if (translateConfigContainer.injector) {
                        currentLanguage = translateConfigContainer.config.languageCode;
                        service = translateConfigContainer.injector.get(config.serviceModel);
                        observable = config.serviceMethod.bind(service).call();
                    }
                }
                else if (currentLanguage != translateConfigContainer.config.languageCode)
                    observable = config.serviceMethod.bind(service).call();
                return observable;
            },
            enumerable: true,
            configurable: true
        });
    }

    function overrideDestroyMethod(model, name) {
        var onDestroy = model.prototype.ngOnDestroy;
        model.prototype.ngOnDestroy = function () {
            MultiLingualData.remove(name);
            viewRefContainer.destroy(this);
            if (onDestroy)
                onDestroy.bind(this).call();
        };
    }

    var translateContainer = new (/** @class */ (function () {
        function class_1() {
            this.store = new Array();
            this.additionalStore = new Array();
            this.componentState = {};
        }
        class_1.prototype.set = function (instance, config) {
            var translateConfig = this.store.filter(function (t) { return t.instance == instance; })[0];
            if (!translateConfig)
                this.store.push({ instance: instance, config: config });
            else
                this.additionalStore.push({ instance: instance, config: config });
        };
        class_1.prototype.get = function (instance) {
            var containerConfig = this.store.filter(function (t) { return t.instance == instance; });
            return containerConfig.length > 0 ? containerConfig[0] : undefined;
        };
        class_1.prototype.additionalGet = function (instance) {
            return this.additionalStore.filter(function (t) { return t.instance == instance; });
        };
        class_1.prototype.getByName = function (name) {
            var containerConfig = this.store.filter(function (t) { return t.config.translationName == name; });
            if (containerConfig.length == 0)
                containerConfig = this.additionalStore.filter(function (t) { return t.config.translationName == name; });
            return containerConfig.length > 0 ? containerConfig[0] : undefined;
        };
        class_1.prototype.defineAsyncProperty = function (instance, propertyName, config) {
            var isPropertyKey = (propertyName != undefined);
            var model = !isPropertyKey ? instance : instance.constructor;
            defineAsyncProperty(model, propertyName, config);
        };
        class_1.prototype.defineProperty = function (instance, propertyName, config) {
            var isPropertyKey = (propertyName != undefined);
            var model = !isPropertyKey ? instance : instance.constructor;
            var modelName = config === undefined ? "global" : config.translationName;
            defineProperty(model, propertyName, modelName, config ? config.language : undefined, config ? config.filePath : undefined);
            if (modelName != "global" && propertyName) {
                var instanceConfig = { instance: model, config: config };
                this.set(model, config);
                var count = this.store.filter(function (t) { return t.instance == model; }).length;
                count = this.additionalStore.filter(function (t) { return t.instance == model; }).length + count;
                if (count == 1)
                    overrideDestroyMethod(model, config.translationName);
                return instanceConfig;
            }
            else if (!propertyName)
                this.set(model, config);
        };
        class_1.prototype.setComponentState = function (key, instance) {
            this.componentState[key] = instance;
        };
        class_1.prototype.getComponentState = function (key) {
            return this.componentState[key];
        };
        class_1.prototype.getActiveTranslations = function () {
            return this.store;
        };
        return class_1;
    }()))();

    function replacer(extractKeys, text, data) {
        if (text && text.indexOf("{{") != -1) {
            var extractor = extract(extractKeys);
            var keys = extractor(text);
            keys.forEach(function (key) {
                text = text.replace("{{" + key + "}}", getValue(key, data));
            });
        }
        return text;
    }

    var BaseResolver = /** @class */ (function () {
        function BaseResolver(baseConfig, httpClient) {
            this.baseConfig = baseConfig;
            this.httpClient = httpClient;
            this.cloneBaseConfig = Object.assign({}, baseConfig);
        }
        BaseResolver.prototype.resolveGlobal = function (config, isGlobal) {
            if (isGlobal === void 0) { isGlobal = true; }
            if (isGlobal)
                translateContainer.set(config.instance, config.config);
            if ((isGlobal && !this.baseConfig.forNgxTranslate) || !isGlobal) {
                translateConfigContainer.globalTranslate = this.resolve(config);
                translateConfigContainer.globalTranslate.subscribe(function (t) {
                    translateConfigContainer.globalTranslate = undefined;
                });
            }
        };
        BaseResolver.prototype.resolve = function (config, languageCode, isRouteLanguageChanged) {
            if (languageCode === void 0) { languageCode = ""; }
            if (isRouteLanguageChanged === void 0) { isRouteLanguageChanged = false; }
            var containerConfig = config;
            if ((containerConfig && this.cloneBaseConfig.isTest) || (containerConfig && !MultiLingualData.contains(getKeyName(containerConfig.config.translationName, languageCode || this.cloneBaseConfig.languageCode), languageCode || this.cloneBaseConfig.languageCode)) || (containerConfig && isRouteLanguageChanged)) {
                var lang_1 = containerConfig.config.language || languageCode || this.cloneBaseConfig.languageCode;
                if (containerConfig.config.inlineTranslations && containerConfig.config.inlineTranslations[lang_1]) {
                    return rxjs.Observable.create(function (subcriber) {
                        containerConfig.config.inlineTranslations[lang_1]().then(function (t) { subcriber.next(t.default); subcriber.complete(); });
                    }).pipe(operators.map(this.setData(lang_1, containerConfig).bind(this)));
                }
                else if (!translateConfigContainer.customLoader) {
                    var url = this.getPath(containerConfig, languageCode);
                    if (url)
                        return this.httpClient.get(url).pipe(operators.map(this.setData(lang_1, containerConfig).bind(this)));
                }
                else {
                    var translationObject = lang_1;
                    if (config.config.translationName != "global")
                        translationObject = Object.assign(Object.assign({}, config.config), { filePath: this.getPath(containerConfig, languageCode), lang: lang_1 });
                    return translateConfigContainer.customLoader.getTranslation(translationObject).pipe(operators.map(this.setData(lang_1, containerConfig).bind(this)));
                }
            }
            else if ((containerConfig && MultiLingualData.contains(getKeyName(containerConfig.config.translationName, languageCode || this.cloneBaseConfig.languageCode), languageCode || this.cloneBaseConfig.languageCode))) {
                var body = MultiLingualData.get(getKeyName(containerConfig.config.translationName, languageCode || this.cloneBaseConfig.languageCode));
                this.setTitle(body, containerConfig);
            }
            return rxjs.of(true);
        };
        BaseResolver.prototype.setTitle = function (body, containerConfig) {
            if (translateConfigContainer.activePageTranslationName == containerConfig.config.translationName)
                this.setPageTitle(body);
        };
        BaseResolver.prototype.setData = function (languageCode, containerConfig) {
            var _this = this;
            return function (body) {
                var name = getKeyName(containerConfig.config.translationName, languageCode || _this.cloneBaseConfig.languageCode, containerConfig.config.filePath);
                var data = body;
                if (translateConfigContainer.resolver)
                    data = translateConfigContainer.resolver(name.replace("global_", "").replace("global", ""), data);
                MultiLingualData.addOrUpdate(name, data, containerConfig.config.translationName, _this.cloneBaseConfig.languageCode);
                _this.setTitle(body, containerConfig);
                setTimeout(function () { MultiLingualData.clearInActives(_this.cloneBaseConfig); }, 10);
                return body;
            };
        };
        BaseResolver.prototype.getPath = function (containerConfig, languageCode) {
            if (languageCode === void 0) { languageCode = ""; }
            var url = '';
            var splitKeywords = ['{{', '}}'];
            languageCode = containerConfig.config.language || languageCode || this.cloneBaseConfig.languageCode;
            if (containerConfig.config.filePath || this.cloneBaseConfig.filePath) {
                if (containerConfig.config.filePath) {
                    var text = replacer(splitKeywords, containerConfig.config.filePath, { "language-code": languageCode, "translation-name": containerConfig.config.translationName });
                    url = "/" + text;
                }
                else {
                    var text = replacer(splitKeywords, this.cloneBaseConfig.filePath, { "language-code": languageCode, "translation-name": containerConfig.config.translationName });
                    url = "/" + text;
                }
            }
            return url;
        };
        BaseResolver.prototype.resolveRoute = function (route) {
            if (route.component) {
                var isRouteLanguageChanged = route.params && route.params["languageCode"] && route.params["languageCode"] != this.cloneBaseConfig.languageCode;
                var containerConfig = translateContainer.get(route.component);
                if (isRouteLanguageChanged) {
                    this.updateLanguageByParam(route);
                    this.cloneBaseConfig.languageCode = route.params["languageCode"];
                    translateConfigContainer.loading = true;
                }
                if (containerConfig) {
                    if (containerConfig.config)
                        translateConfigContainer.activePageTranslationName = containerConfig.config.translationName;
                    return this.resolveData(containerConfig, '', isRouteLanguageChanged);
                }
                else if (isRouteLanguageChanged && translateConfigContainer.ngxTranslate) {
                    translateConfigContainer.ngxTranslate.use(route.params["languageCode"]);
                    translateConfigContainer.loading = false;
                }
            }
            return rxjs.of(true);
        };
        BaseResolver.prototype.resolveData = function (containerConfig, languageCode, isRouteLanguageChanged) {
            var _this = this;
            if (isRouteLanguageChanged === void 0) { isRouteLanguageChanged = false; }
            var additionalContainerConfigs = translateContainer.additionalGet(containerConfig.instance);
            var observables = new Array();
            additionalContainerConfigs.forEach(function (config) {
                observables.push(_this.resolve(config, languageCode, isRouteLanguageChanged));
            });
            observables.push(this.resolve(containerConfig, languageCode, isRouteLanguageChanged));
            return rxjs.forkJoin(observables).pipe(operators.map(function (response) {
                _this.baseConfig.languageCode = _this.cloneBaseConfig.languageCode;
                translateConfigContainer.loading = false;
                if (isRouteLanguageChanged && translateConfigContainer.ngxTranslate)
                    translateConfigContainer.ngxTranslate.use(_this.baseConfig.languageCode);
                return true;
            }));
        };
        BaseResolver.prototype.updateLanguageByParam = function (route) {
            var _this = this;
            if (route.params && route.params["languageCode"] && (!this.baseConfig.languageCode || this.baseConfig.languageCode !== route.params["languageCode"])) {
                setTimeout(function () { return _this.languageChanged(route.params["languageCode"]); }, 10);
            }
        };
        BaseResolver.prototype.languageChanged = function (languageCode, onComplete) {
            var keys = this.getKeys(this.baseConfig.languageCode);
            this.cloneBaseConfig.languageCode = languageCode;
            this.changeTranslation(keys, 0, onComplete);
        };
        BaseResolver.prototype.resolveByName = function (name, languageCode) {
            if (languageCode === void 0) { languageCode = null; }
            var containerConfig = translateContainer.getByName(name);
            return this.resolve(containerConfig, languageCode);
        };
        BaseResolver.prototype.fakeResolveByName = function (name, fakeData, resolve) {
        };
        BaseResolver.prototype.getKeys = function (languageCode) {
            return MultiLingualData.getActiveKeys().map(function (key) {
                return key.replace("_" + languageCode, '');
            });
        };
        BaseResolver.prototype.changeTranslation = function (keys, index, onComplete) {
            var _this = this;
            if (keys.length > index) {
                translateConfigContainer.loading = true;
                var baseResolver = new BaseResolver(this.cloneBaseConfig, this.httpClient);
                baseResolver.resolveByName(keys[index]).subscribe(function (x) {
                    var nextIndex = index + 1;
                    _this.changeTranslation(keys, nextIndex, onComplete);
                });
            }
            else {
                translateConfigContainer.config.languageCode = this.cloneBaseConfig.languageCode;
                translateConfigContainer.loading = false;
                if (onComplete)
                    onComplete();
            }
        };
        BaseResolver.prototype.setPageTitle = function (body) {
            if (body && body["pageTitle"])
                document.title = body["pageTitle"];
        };
        return BaseResolver;
    }());

    function translate(config) {
        return function (target, propertyKey, parameterIndex) {
            var instanceConfig = translateContainer.defineProperty(target, propertyKey, config);
            if (translateConfigContainer.config && translateConfigContainer.config.preloadingStrategy && instanceConfig != undefined) {
                var baseResolver = new BaseResolver(translateConfigContainer.config, translateConfigContainer.httpClient);
                baseResolver.resolveGlobal(instanceConfig, false);
            }
        };
    }

    function asyncTranslate(config) {
        return function (target, propertyKey, parameterIndex) {
            translateContainer.defineAsyncProperty(target, propertyKey, config);
        };
    }

    var TranslationCore = new (/** @class */ (function () {
        function class_1() {
            this.languageChangedSubject = new rxjs.Subject();
            this.languageChanged = this.languageChangedSubject.asObservable();
        }
        class_1.prototype.getText = function (path) {
            var e_1, _a;
            var splitText = path.split('.');
            var keyName = getKeyName(splitText[0]);
            var data = MultiLingualData.get(keyName);
            var text = '';
            if (data) {
                splitText.splice(0, 1);
                try {
                    for (var splitText_1 = __values(splitText), splitText_1_1 = splitText_1.next(); !splitText_1_1.done; splitText_1_1 = splitText_1.next()) {
                        var col = splitText_1_1.value;
                        text = text ? text[col] : data[col];
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (splitText_1_1 && !splitText_1_1.done && (_a = splitText_1.return)) _a.call(splitText_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
            return text;
        };
        return class_1;
    }()));

    var RxTranslation = /** @class */ (function () {
        function RxTranslation(httpClient, ref) {
            this.httpClient = httpClient;
            this.ref = ref;
        }
        Object.defineProperty(RxTranslation.prototype, "language", {
            get: function () {
                return translateConfigContainer.config.languageCode;
            },
            enumerable: false,
            configurable: true
        });
        RxTranslation.prototype.change = function (languageCode, onComplete) {
            var baseResolver = new BaseResolver(translateConfigContainer.config, this.httpClient);
            baseResolver.languageChanged(languageCode, function () {
                viewRefContainer.markForCheck();
                if (onComplete)
                    onComplete();
                TranslationCore.languageChangedSubject.next(true);
            });
        };
        RxTranslation.prototype.translate = function (text, data) {
            var extractor = extract(['{', '}']);
            var keys = extractor(text);
            keys.forEach(function (key) {
                text = text.replace("{" + key + "}", getValue(key, data));
            });
            return text;
        };
        return RxTranslation;
    }());
    RxTranslation.decorators = [
        { type: core.Injectable }
    ];
    RxTranslation.ctorParameters = function () { return [
        { type: http.HttpClient },
        { type: core.ApplicationRef }
    ]; };

    var RxTranslateConfig = /** @class */ (function () {
        function RxTranslateConfig() {
            this.allowedLanguages = [];
        }
        return RxTranslateConfig;
    }());

    var RX_TRANSLATE_CONFIG = "rxTranslateConfig";
    var CUSTOM_LOADER = "customLoader";

    var ComponentGuard = /** @class */ (function (_super) {
        __extends(ComponentGuard, _super);
        function ComponentGuard(config, injector, customLoader, httpClient) {
            var _this = _super.call(this, config, httpClient) || this;
            translateConfigContainer.injector = injector;
            if (!translateConfigContainer.customLoader)
                translateConfigContainer.customLoader = customLoader;
            return _this;
        }
        ComponentGuard.prototype.canActivateChild = function (childRoute, state) {
            return this.resolveGlobalTranslate(childRoute);
        };
        ComponentGuard.prototype.canActivate = function (route, state) {
            return this.resolveGlobalTranslate(route);
        };
        ComponentGuard.prototype.resolveGlobalTranslate = function (route) {
            var _this = this;
            this.cloneBaseConfig = Object.assign({}, translateConfigContainer.config);
            if (translateConfigContainer.globalTranslate) {
                return rxjs.Observable.create(function (subscriber) {
                    translateConfigContainer.globalTranslate.subscribe(function (t) {
                        _this.resolveRoute(route).subscribe(function (x) { subscriber.next(x); subscriber.complete(); });
                    });
                });
            }
            else
                return this.resolveRoute(route);
        };
        return ComponentGuard;
    }(BaseResolver));
    ComponentGuard.decorators = [
        { type: core.Injectable }
    ];
    ComponentGuard.ctorParameters = function () { return [
        { type: RxTranslateConfig, decorators: [{ type: core.Inject, args: [RX_TRANSLATE_CONFIG,] }] },
        { type: core.Injector },
        { type: undefined, decorators: [{ type: core.Inject, args: [CUSTOM_LOADER,] }] },
        { type: http.HttpClient }
    ]; };

    var RxTranslateDirective = /** @class */ (function () {
        function RxTranslateDirective(viewContainerRef, templateRef, injector, baseConfig, route, httpClient) {
            this.viewContainerRef = viewContainerRef;
            this.templateRef = templateRef;
            this.injector = injector;
            this.route = route;
            this.httpClient = httpClient;
            this.viewRef = null;
            this._context = new common.NgIfContext();
            var ref = this.templateRef;
            this.baseConfig = translateConfigContainer.config.forNgxTranslate ? translateConfigContainer.config : baseConfig;
            var elementName = null;
            if (ref._def) {
                elementName = ref._def.element.template.nodes[0].element.name;
                var node = ref._def.element.template.nodes[ref._def.element.template.nodes.length - 1];
                this.component = node.provider.token;
                this.config = translateContainer.get(node.provider.token);
            }
            else if (ref._declarationTContainer) {
                var tagName_1 = ref._declarationTContainer.tagName;
                elementName = tagName_1.toLowerCase();
                var tView = ref._declarationTContainer.tView_ || ref._declarationTContainer.tViews;
                var node = tView.directiveRegistry.filter(function (t) { return t.selectors.filter(function (y) { return y == tagName_1; })[0] != undefined; })[0];
                if (node) {
                    this.config = translateContainer.get(node.type);
                    this.component = node.type;
                }
            }
            if (baseConfig.forNgxTranslate && this.component && elementName)
                translateContainer.setComponentState(elementName, this.component);
        }
        Object.defineProperty(RxTranslateDirective.prototype, "translate", {
            set: function (value) {
                var _this = this;
                if (this.config) {
                    var baseResolver = new BaseResolver(this.baseConfig, this.httpClient);
                    var languageCode = "";
                    if (this.route.params && this.route.params["languageCode"] && this.baseConfig.languageCode !== this.route.params["languageCode"] && !this.config.config.language)
                        languageCode = this.route.params["languageCode"];
                    this.subscription = baseResolver.resolveData(this.config, languageCode).subscribe(function (x) {
                        _this.updateView(x);
                    });
                }
                else
                    this.updateView(true);
            },
            enumerable: false,
            configurable: true
        });
        RxTranslateDirective.prototype.updateView = function (value) {
            if (this.viewRef) {
                this.viewContainerRef.clear();
                this.viewRef = null;
            }
            if (value)
                this.viewRef = this.viewContainerRef.createEmbeddedView(this.templateRef, this._context);
            else
                this.viewContainerRef.clear();
        };
        RxTranslateDirective.prototype.ngOnDestroy = function () {
            if (this.subscription)
                this.subscription.unsubscribe();
            viewRefContainer.destroy(this.component);
        };
        return RxTranslateDirective;
    }());
    RxTranslateDirective.decorators = [
        { type: core.Directive, args: [{
                    selector: '[rxTranslate]'
                },] }
    ];
    RxTranslateDirective.ctorParameters = function () { return [
        { type: core.ViewContainerRef },
        { type: core.TemplateRef },
        { type: core.Injector },
        { type: RxTranslateConfig, decorators: [{ type: core.Inject, args: [RX_TRANSLATE_CONFIG,] }] },
        { type: router.ActivatedRoute },
        { type: http.HttpClient }
    ]; };
    RxTranslateDirective.propDecorators = {
        translate: [{ type: core.Input, args: ['rxTranslate',] }]
    };

    function overrideProperty() {
        Object.defineProperty(router.ActivatedRouteSnapshot.prototype, "routeConfig", {
            get: function () { return this.cloneSnap; },
            set: function (v) {
                this.cloneSnap = v;
                if (this.cloneSnap && !this.cloneSnap.canActivate) {
                    this.cloneSnap.canActivate = [ComponentGuard];
                }
                else if (this.cloneSnap && this.cloneSnap.canActivate) {
                    if (this.cloneSnap.canActivate.filter(function (t) { return t == ComponentGuard; }).length == 0) {
                        this.cloneSnap.canActivate.push(ComponentGuard);
                    }
                }
                if (this.cloneSnap && this.cloneSnap.children) {
                    if (this.cloneSnap && !this.cloneSnap.canActivateChild) {
                        this.cloneSnap.canActivateChild = [ComponentGuard];
                    }
                    else if (this.cloneSnap && this.cloneSnap.canActivateChild) {
                        if (this.cloneSnap.canActivateChild.filter(function (t) { return t == ComponentGuard; }).length == 0)
                            this.cloneSnap.canActivateChild.push(ComponentGuard);
                    }
                }
            },
            enumerable: true,
            configurable: true
        });
    }

    var NOT_IN = ["min", "max"];
    function overrideErrorsProperty(errorMessageConfig) {
        var language = translateConfigContainer.config.languageCode;
        Object.defineProperty(forms.AbstractControl.prototype, "errors", {
            get: function () {
                if (this.originalErrors && this.originalErrors.languageCode != translateConfigContainer.config.languageCode) {
                    this.cloneErrors = getTranslatedErrorMessages(errorMessageConfig, Object.assign({}, this.originalErrors), this.value);
                }
                return this.cloneErrors;
            },
            set: function (v) {
                this.originalErrors = v;
                this.cloneErrors = v;
                if (v && isObject(v))
                    this.cloneErrors = getTranslatedErrorMessages(errorMessageConfig, Object.assign({}, v), this.value);
            },
            enumerable: true,
            configurable: true
        });
    }
    function getTranslatedErrorMessages(errorMessageConfig, errors, value) {
        var keyName = getKeyName("global");
        var data = MultiLingualData.get(keyName);
        if (data) {
            data = errorMessageConfig.path == "" ? data : getValue(errorMessageConfig.path, data);
            if (errors && isObject(errors)) {
                Object.keys(errors).forEach(function (key) {
                    if (errors[key]) {
                        var message_1 = '';
                        if (data[key])
                            message_1 = getMessage(data, key);
                        if (message_1) {
                            Object.keys(errors[key]).forEach(function (t) {
                                if (Array.isArray(errors[key][t])) {
                                    errors[key][t].forEach(function (x, i) {
                                        message_1 = message_1.replace("{{" + i + "}}", errors[key][t][i]);
                                    });
                                }
                                else
                                    message_1 = message_1.replace("{{" + t + "}}", errors[key][t]);
                            });
                            value = value ? value : '';
                            message_1 = message_1.replace("{{value}}", value);
                        }
                        if (!isObject(errors[key]))
                            errors[key] = {};
                        errors[key]["message"] = message_1;
                    }
                });
                errors["languageCode"] = translateConfigContainer.config.languageCode;
            }
        }
        return errors;
    }
    function getMessage(data, key) {
        var text = data[key];
        if (text.indexOf('{{') !== -1) {
            var stringExtractor = extract(['{{', '}}']);
            var keys = stringExtractor(text);
            keys.forEach(function (key) {
                var value = runPipe(key, data, data);
                if (key == value && NOT_IN.indexOf(key) == -1) {
                    value = getValue(key, data);
                    if (value) {
                        text = text.replace("{{" + key + "}}", value);
                    }
                }
            });
        }
        return text;
    }

    var TranslationResolver = /** @class */ (function () {
        function TranslationResolver(httpClient) {
            this.httpClient = httpClient;
            this._allowedLanguages = [];
        }
        Object.defineProperty(TranslationResolver.prototype, "controlErrorMessage", {
            set: function (value) {
                if (translateConfigContainer.config && !translateConfigContainer.config.controlErrorMessage) {
                    translateConfigContainer.config.controlErrorMessage = value;
                    overrideErrorsProperty(translateConfigContainer.config.controlErrorMessage);
                }
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TranslationResolver.prototype, "resolver", {
            set: function (value) {
                translateConfigContainer.resolver = value;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TranslationResolver.prototype, "allowedLanguages", {
            get: function () {
                return this._allowedLanguages;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TranslationResolver.prototype, "activeTranslationsLength", {
            get: function () {
                return translateContainer.getActiveTranslations().length;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TranslationResolver.prototype, "ngxTranslate", {
            set: function (value) {
                translateConfigContainer.ngxTranslate = value;
                translateConfigContainer.customLoader = value.customLoader;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TranslationResolver.prototype, "injector", {
            get: function () {
                return translateConfigContainer.injector;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TranslationResolver.prototype, "pending", {
            get: function () {
                return translateConfigContainer.loading;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TranslationResolver.prototype, "activeLanguage", {
            get: function () {
                return translateConfigContainer.config.languageCode;
            },
            set: function (lang) {
                translateConfigContainer.config.languageCode = lang;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(TranslationResolver.prototype, "translations", {
            get: function () {
                return MultiLingualData.data;
            },
            enumerable: false,
            configurable: true
        });
        TranslationResolver.prototype.getTranslationName = function (nodeName, languageCode) {
            if (languageCode === void 0) { languageCode = null; }
            var instance = translateContainer.getComponentState(nodeName);
            if (instance) {
                var translateConfig = translateContainer.get(instance);
                if (translateConfig && translateConfig.config)
                    return getKeyName(translateConfig.config.translationName, languageCode);
            }
            return null;
        };
        TranslationResolver.prototype.getTranslationNameByInstance = function (instance, languageCode) {
            if (languageCode === void 0) { languageCode = null; }
            var translateConfig = translateContainer.get(instance);
            if (translateConfig && translateConfig.config)
                return getKeyName(translateConfig.config.translationName, languageCode);
            return null;
        };
        TranslationResolver.prototype.get = function (modelName, languageCode) {
            if (languageCode === void 0) { languageCode = ''; }
            return MultiLingualData.get(this.getKeyName(modelName, languageCode));
        };
        TranslationResolver.prototype.getKeyName = function (modelName, languageCode) {
            if (languageCode === void 0) { languageCode = ''; }
            return getKeyName(modelName, languageCode);
        };
        TranslationResolver.prototype.resolve = function (modelName, languageCode) {
            var baseResolver = new BaseResolver(translateConfigContainer.config, this.httpClient);
            return baseResolver.resolveByName(modelName, languageCode);
        };
        TranslationResolver.prototype.addConfig = function (name) {
            var containerConfig = translateContainer.getByName(name);
            if (!containerConfig)
                translateContainer.set(null, { translationName: name });
        };
        return TranslationResolver;
    }());
    TranslationResolver.decorators = [
        { type: core.Injectable }
    ];
    TranslationResolver.ctorParameters = function () { return [
        { type: http.HttpClient }
    ]; };

    var RxTranslatePipe = /** @class */ (function () {
        function RxTranslatePipe() {
        }
        RxTranslatePipe.prototype.transform = function (text, params) {
            if (text && params && Object.keys(params).length > 0) {
                if (text.indexOf('{{{this') !== -1) {
                    var stringExtractor = extract(['{{{', '}}}']);
                    var keys = stringExtractor(text);
                    keys.forEach(function (t) {
                        var func = new Function("x", "return " + t);
                        var calculatedText = func.call(params);
                        text = text.replace("{{{" + t + "}}}", calculatedText);
                    });
                }
                if (text && text.indexOf("{{") != -1) {
                    var stringExtractor = extract(['{{', '}}']);
                    var keys = stringExtractor(text);
                    keys.forEach(function (key) {
                        var value = getValue(key, params);
                        text = text.replace("{{" + key + "}}", value);
                    });
                }
            }
            return text;
        };
        return RxTranslatePipe;
    }());
    RxTranslatePipe.decorators = [
        { type: core.Pipe, args: [{ name: 'rxTranslate' },] }
    ];

    var RxTranslateModule = /** @class */ (function () {
        function RxTranslateModule(config, httpClient) {
            if (!translateConfigContainer.config) {
                translateConfigContainer.httpClient = httpClient;
                translateConfigContainer.config = config;
                if (!translateConfigContainer.config.languageCode)
                    translateConfigContainer.config.languageCode = "en";
                var translateConfig = { config: { translationName: 'global', filePath: config.globalFilePath }, instance: null };
                var baseResolver = new BaseResolver(config, httpClient);
                baseResolver.resolveGlobal(translateConfig);
                overrideProperty();
                if (config.controlErrorMessage)
                    overrideErrorsProperty(config.controlErrorMessage);
            }
        }
        RxTranslateModule.forRoot = function (config) {
            return {
                ngModule: RxTranslateModule,
                providers: [
                    ComponentGuard, RxTranslation,
                    { provide: RX_TRANSLATE_CONFIG, useValue: config },
                    config.loader ? { provide: CUSTOM_LOADER, useClass: config.loader } : { provide: CUSTOM_LOADER, useValue: null },
                ]
            };
        };
        return RxTranslateModule;
    }());
    RxTranslateModule.decorators = [
        { type: core.NgModule, args: [{
                    imports: [router.RouterModule, http.HttpClientModule],
                    declarations: [RxTranslateDirective, RxTranslatePipe],
                    providers: [ComponentGuard, RxTranslation, TranslationResolver, { provide: CUSTOM_LOADER, useValue: null }],
                    exports: [RxTranslateDirective, RxTranslatePipe],
                },] }
    ];
    RxTranslateModule.ctorParameters = function () { return [
        { type: RxTranslateConfig, decorators: [{ type: core.Inject, args: [RX_TRANSLATE_CONFIG,] }] },
        { type: http.HttpClient }
    ]; };

    var RxTranslateSanitizeModule = /** @class */ (function () {
        function RxTranslateSanitizeModule() {
        }
        return RxTranslateSanitizeModule;
    }());
    RxTranslateSanitizeModule.decorators = [
        { type: core.NgModule, args: [{
                    imports: [common.CommonModule],
                    providers: [common.CurrencyPipe, common.DatePipe, common.DecimalPipe, common.I18nPluralPipe, common.I18nSelectPipe, common.LowerCasePipe, common.PercentPipe, common.SlicePipe, common.TitleCasePipe, common.UpperCasePipe],
                },] }
    ];

    function sanitize(config) {
        return function (target) {
            PIPE_CONFIG[config.name] = target;
        };
    }

    /**
     * Generated bundle index. Do not edit.
     */

    exports.RxTranslateModule = RxTranslateModule;
    exports.RxTranslatePipe = RxTranslatePipe;
    exports.RxTranslateSanitizeModule = RxTranslateSanitizeModule;
    exports.RxTranslation = RxTranslation;
    exports.TranslationCore = TranslationCore;
    exports.TranslationResolver = TranslationResolver;
    exports.asyncTranslate = asyncTranslate;
    exports.equals = equals;
    exports.replacer = replacer;
    exports.sanitize = sanitize;
    exports.translate = translate;
    exports.a = RxTranslateDirective;
    exports.b = RX_TRANSLATE_CONFIG;
    exports.c = CUSTOM_LOADER;
    exports.d = RxTranslateConfig;
    exports.e = ComponentGuard;
    exports.f = BaseResolver;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=rxweb-translate.umd.js.map
