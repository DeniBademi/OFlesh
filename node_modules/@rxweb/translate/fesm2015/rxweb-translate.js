import { CurrencyPipe, DatePipe, DecimalPipe, I18nPluralPipe, I18nSelectPipe, SlicePipe, LowerCasePipe, UpperCasePipe, PercentPipe, TitleCasePipe, NgIfContext, CommonModule } from '@angular/common';
import { ChangeDetectorRef, Injectable, ApplicationRef, Inject, Injector, Directive, ViewContainerRef, TemplateRef, Input, Pipe, NgModule } from '@angular/core';
import { Observable, of, forkJoin, Subject } from 'rxjs';
import { map } from 'rxjs/operators';
import { HttpClient, HttpClientModule } from '@angular/common/http';
import { ActivatedRoute, ActivatedRouteSnapshot, RouterModule } from '@angular/router';
import { AbstractControl } from '@angular/forms';

const MultiLingualData = new (class {
    constructor() {
        this.translationModelData = new Array();
        this.data = {};
        this.keys = {};
        this.contentKeysByLanguage = {};
    }
    addOrUpdate(key, data, translationName, languageCode) {
        this.data[key] = data;
        this.keys[translationName] = true;
        if (languageCode)
            this.contentKeysByLanguage[key] = languageCode;
    }
    addOrUpdateComponent(key, data, instance, refMarkedId) {
        let indexOf = this.translationModelData.findIndex(t => t.instance == instance && t.key == key && t.rxRefMarkedId == refMarkedId);
        if (indexOf != -1)
            this.translationModelData[indexOf] = { key: key, data: data, instance: instance, rxRefMarkedId: refMarkedId };
        else
            this.translationModelData.push({ key: key, data: data, instance: instance, rxRefMarkedId: refMarkedId });
    }
    getComponentPropValue(key, instance, refMarkedId) {
        let indexOf = this.translationModelData.findIndex(t => t.instance == instance && t.key == key && t.rxRefMarkedId == refMarkedId);
        return indexOf != -1 ? this.translationModelData[indexOf].data : undefined;
    }
    removeComponentPropValue(instance, refMarkedId, keyName) {
        let indexOf = -1;
        if (keyName)
            indexOf = this.translationModelData.findIndex(t => t.instance == instance && t.rxRefMarkedId == refMarkedId && t.key == keyName);
        else {
            let result = this.translationModelData.filter(t => t.instance == instance && t.rxRefMarkedId == refMarkedId);
            for (let data of result) {
                this.translationModelData.splice(this.translationModelData.indexOf(data), 1);
            }
        }
        return indexOf != -1 ? this.translationModelData.splice(indexOf, 1) : undefined;
    }
    contains(key, languageCode) {
        return this.data[key] ? this.contentKeysByLanguage[key] == languageCode : false;
    }
    get(key) {
        return this.data[key] ? this.data[key] : undefined;
    }
    clearInActives(config) {
        if (!config.cacheActiveLanguageObject || (!config.cacheActiveLanguageObject && !config.cacheLanguageWiseObject))
            Object.keys(this.keys).forEach(t => {
                if (!this.keys[t] && this.data[t]) {
                    delete this.data[t];
                }
            });
    }
    getActiveKeys() {
        return Object.keys(this.keys);
    }
    remove(key) {
        this.keys[key] = undefined;
    }
});

function isObject(value) {
    return Object.prototype.toString.call(value) === '[object Object]';
}

function extract([start, end]) {
    const matcher = new RegExp(`${start}(.*?)${end}`, 'gm');
    const normalise = (str) => str.slice(start.length, end.length * -1);
    return function (str) {
        return str.match(matcher).map(normalise);
    };
}

function getValue(key, data) {
    let isObjectKey = key.indexOf(".") !== -1;
    if (isObjectKey) {
        let keys = key.split('.');
        let jObject = data;
        for (let column of keys) {
            if (jObject[column])
                jObject = jObject[column];
            else {
                jObject = "";
                break;
            }
        }
        return jObject;
    }
    let value = data[key];
    return value == undefined ? '' : value;
}

const translateConfigContainer = new (class {
})();

function equals(o1, o2) {
    if (o1 === o2)
        return true;
    if (o1 === null || o2 === null)
        return false;
    if (o1 !== o1 && o2 !== o2)
        return true; // NaN === NaN
    let t1 = typeof o1, t2 = typeof o2, length, key, keySet;
    if (t1 == t2 && t1 == 'object') {
        if (Array.isArray(o1)) {
            if (!Array.isArray(o2))
                return false;
            if ((length = o1.length) == o2.length) {
                for (key = 0; key < length; key++) {
                    if (!equals(o1[key], o2[key]))
                        return false;
                }
                return true;
            }
        }
        else {
            if (Array.isArray(o2)) {
                return false;
            }
            keySet = Object.create(null);
            for (key in o1) {
                if (!equals(o1[key], o2[key])) {
                    return false;
                }
                keySet[key] = true;
            }
            for (key in o2) {
                if (!(key in keySet) && typeof o2[key] !== 'undefined') {
                    return false;
                }
            }
            return true;
        }
    }
    return false;
}

function getKeyName(name, languageCode, filePath) {
    if (translateConfigContainer.config && translateConfigContainer.config.cacheLanguageWiseObject && (!filePath || (filePath && name == "global")))
        return `${name}_${languageCode || translateConfigContainer.config.languageCode}`;
    return name;
}

const PIPE_CONFIG = {
    'currency': CurrencyPipe,
    'date': DatePipe,
    'decimal': DecimalPipe,
    'i18nPlural': I18nPluralPipe,
    'i18nSelect': I18nSelectPipe,
    'slice': SlicePipe,
    'lowercase': LowerCasePipe,
    'uppercase': UpperCasePipe,
    'percent': PercentPipe,
    'titlecase': TitleCasePipe
};

function getInstanceValue(key, componentData, parentData) {
    let value = "";
    if (key.indexOf("'") != 0) {
        value = getValue(key, parentData);
        if (!value)
            value = getValue(key, componentData);
    }
    return value == "" ? key.replace(new RegExp(/[']/, "g"), "") : value;
}

function runPipe(text, componentData, parentData) {
    let pipeName = '';
    if (text.indexOf("|") !== -1) {
        let splitText = text.split("|");
        let leftText = getInstanceValue(splitText[0].trim(), componentData, parentData);
        let rightText = splitText[1].split(new RegExp(":(?=([^\"]*\"[^\"]*\")*[^\"]*$)")).filter(t => t !== undefined).map(t => getInstanceValue(t, componentData, parentData));
        pipeName = rightText[0].trim();
        rightText.splice(0, 1);
        if (translateConfigContainer.injector && pipeName && PIPE_CONFIG[pipeName]) {
            let resolve = translateConfigContainer.injector.get(PIPE_CONFIG[pipeName]);
            text = resolve.transform.apply(resolve, [leftText, ...rightText]);
        }
    }
    return text;
}

class TranslateModel {
    constructor(raw, componentData, modelName, parentData) {
        this.raw = raw;
        this.componentData = componentData;
        this.modelName = modelName;
        this.parentData = parentData;
        this.keyParameters = {};
        this.memoized = {};
        this.thisParameter = {};
        let data = raw;
        if (data)
            Object.keys(data).forEach(key => {
                Object.defineProperty(this, key, {
                    get: function () {
                        let text = data[key];
                        if (isObject(text)) {
                            if (!(data[key] instanceof TranslateModel)) {
                                let pData = Object.keys(parentData).length == 0 ? data : parentData;
                                if (!translateConfigContainer.loading)
                                    text = data[key] = new TranslateModel(data[key], componentData, modelName, pData);
                                else
                                    return new TranslateModel(data[key], {}, modelName, pData);
                            }
                            else
                                text = data[key];
                            return text;
                        }
                        return translateConfigContainer.loading ? "loading..." : this.transform(data, key, text);
                    },
                    enumerable: true,
                    configurable: true
                });
            });
    }
    getKeyValue(keyParamObject) {
        let keyValue = {};
        Object.keys(keyParamObject).forEach(key => {
            keyValue[key] = getValue(key, this.componentData);
        });
        return keyValue;
    }
    transform(data, key, text) {
        if (this.thisParameter[key])
            return this.getText(data, text, key);
        if (this.keyParameters && this.keyParameters[key] && isObject(this.keyParameters[key])) {
            if (!equals(this.keyParameters[key], this.getKeyValue(this.keyParameters[key])))
                return this.getText(data, text, key);
            else if (this.memoized[key])
                return this.memoized[key];
        }
        if (this.keyParameters && !this.keyParameters[key])
            return this.getText(data, text, key);
        else
            return typeof text === "function" ? text() : text;
    }
    get languageCode() {
        return translateConfigContainer.config ? translateConfigContainer.config.languageCode : "en";
    }
    get(key) {
        let jObject;
        if (key) {
            var keys = key.split(".");
            for (let column of keys) {
                if (!jObject)
                    jObject = this[column];
                else
                    jObject = jObject[column];
            }
        }
        return jObject;
    }
    addOrUpdateKey(name, value) {
        let keyName = getKeyName(this.modelName, this.languageCode, undefined);
        let data = MultiLingualData.get(keyName);
        if (!isObject(value))
            data[name] = value;
        else if (data[name])
            data[name] = Object.assign(Object.assign({}, data[name]), value);
        else
            data[name] = value;
        MultiLingualData.addOrUpdate(keyName, data, this.languageCode);
        MultiLingualData.removeComponentPropValue(this.componentData.constructor, this.componentData["__ngContext__"].rxRefMarkedId, keyName);
    }
    ngxTranslateParser(translations, key) {
        return translateConfigContainer.ngxTranslate["getParsedResult"](translations, key, null);
    }
    getText(translations, text, columnKey) {
        text = translateConfigContainer.ngxTranslate ? this.ngxTranslateParser(translations, columnKey) : text;
        if (text.indexOf('this.') !== -1 || text.indexOf('{{{this') !== -1) {
            this.thisParameter[columnKey] = true;
            if (text.indexOf('{{{this') !== -1) {
                let stringExtractor = extract(['{{{', '}}}']);
                let keys = stringExtractor(text);
                keys.forEach(t => {
                    var func = new Function("x", "return " + t);
                    let calculatedText = func.call(this.componentData);
                    text = text.replace(`{{{${t}}}}`, calculatedText);
                });
            }
            else {
                var func = new Function("x", "return " + text);
                text = func.call(this.componentData);
            }
        }
        if (text && text.indexOf("{{") != -1) {
            let stringExtractor = extract(['{{', '}}']);
            let keys = stringExtractor(text);
            keys.forEach(key => {
                let value = runPipe(key, this.componentData, this.parentData);
                if (key == value) {
                    value = getValue(key, this.parentData);
                    if (!value)
                        value = getValue(key, this.componentData);
                }
                if (!this.keyParameters[columnKey])
                    this.keyParameters[columnKey] = {};
                this.keyParameters[columnKey][key] = value;
                text = text.replace(`{{${key}}}`, value);
            });
            this.memoized[columnKey] = text;
        }
        else
            this.keyParameters[columnKey] = true;
        return text;
    }
}

const NG_CONTEXT$1 = "__ngContext__";
const NG_ELEMENT_ID = "__NG_ELEMENT_ID__";
const LVIEW = "_lView";
const CD_REF_INJECTING_VIEW = "_cdRefInjectingView";
const CONSTRUCTOR = "constructor";
class RxChangeDetectorRef extends ChangeDetectorRef {
    constructor(instance) {
        super();
        this.instance = instance;
    }
    createViewRef() {
        if (this.instance[NG_CONTEXT$1] && this.instance[NG_CONTEXT$1].rxRefMarkedId === undefined) {
            let emulatedDom = this.instance[NG_CONTEXT$1][11];
            if (emulatedDom && emulatedDom.component && emulatedDom.component.onPush) {
                this.viewRef = super[CONSTRUCTOR][NG_ELEMENT_ID]();
                this.viewRef[LVIEW] = this.viewRef[CD_REF_INJECTING_VIEW] = this.instance[NG_CONTEXT$1][14];
            }
            this.setDestroyHooks();
            this.instance[NG_CONTEXT$1].rxRefMarkedId = Math.random();
        }
        return this.viewRef;
    }
    setDestroyHooks() {
        let tView = this.instance[NG_CONTEXT$1][1];
        if (!tView.destroyHooks)
            tView.destroyHooks = [this.instance[NG_CONTEXT$1].length - 1, () => { MultiLingualData.removeComponentPropValue(this.instance.constructor, this.instance[NG_CONTEXT$1].rxRefMarkedId); }];
        else
            tView.destroyHooks.push(this.instance[NG_CONTEXT$1].length - 1, () => {
                MultiLingualData.removeComponentPropValue(this.instance.constructor, this.instance[NG_CONTEXT$1].rxRefMarkedId);
            });
    }
    markForCheck() {
        this.viewRef.markForCheck();
    }
    detach() {
        throw new Error("Method not implemented.");
    }
    detectChanges() {
        throw new Error("Method not implemented.");
    }
    checkNoChanges() {
        throw new Error("Method not implemented.");
    }
    reattach() {
        throw new Error("Method not implemented.");
    }
}

const NG_CONTEXT = "__ngContext__";
const viewRefContainer = new (class {
    constructor() {
        this.viewRefs = new Array();
        this.increment = 1;
    }
    create(instance) {
        var changeDetector = new RxChangeDetectorRef(instance);
        if (changeDetector.createViewRef())
            this.viewRefs.push(changeDetector);
        return instance[NG_CONTEXT] ? instance[NG_CONTEXT].rxRefMarkedId : 0;
    }
    markForCheck() {
        this.viewRefs.forEach(cd => {
            cd.markForCheck();
        });
    }
    destroy(instance) {
        if (instance[NG_CONTEXT] && instance[NG_CONTEXT].rxRefMarkedId !== undefined) {
            let indexOf = this.viewRefs.findIndex(t => t.instance[NG_CONTEXT].rxRefMarkedId == instance[NG_CONTEXT].rxRefMarkedId);
            if (indexOf != -1)
                this.viewRefs.splice(indexOf, 1);
        }
    }
})();

function defineProperty(model, propertyName, modelName, languageCode, filePath) {
    let data = null;
    Object.defineProperty(model.prototype, propertyName, {
        get: function () {
            let keyName = getKeyName(modelName, languageCode, filePath);
            data = MultiLingualData.get(keyName);
            let refMarkedId = this["__ngContext__"] ? this["__ngContext__"].rxRefMarkedId : 0;
            let translationModelData = MultiLingualData.getComponentPropValue(keyName, this.constructor, refMarkedId);
            if ((data && !translationModelData))
                if (!translateConfigContainer.loading) {
                    refMarkedId = viewRefContainer.create(this);
                    MultiLingualData.addOrUpdateComponent(keyName, new TranslateModel(Object.assign({}, data), this, modelName, {}), this.constructor, refMarkedId);
                }
                else
                    return new TranslateModel(data, {}, modelName, {});
            let value = MultiLingualData.getComponentPropValue(keyName, this.constructor, refMarkedId);
            return value === undefined ? {} : value;
        },
        enumerable: true,
        configurable: true
    });
}

function defineAsyncProperty(model, propertyName, config) {
    let observable = null;
    let service = null;
    let currentLanguage = null;
    Object.defineProperty(model.prototype, propertyName, {
        get: function () {
            if (!observable || currentLanguage != translateConfigContainer.config.languageCode) {
                if (translateConfigContainer.injector) {
                    currentLanguage = translateConfigContainer.config.languageCode;
                    service = translateConfigContainer.injector.get(config.serviceModel);
                    observable = config.serviceMethod.bind(service).call();
                }
            }
            else if (currentLanguage != translateConfigContainer.config.languageCode)
                observable = config.serviceMethod.bind(service).call();
            return observable;
        },
        enumerable: true,
        configurable: true
    });
}

function overrideDestroyMethod(model, name) {
    let onDestroy = model.prototype.ngOnDestroy;
    model.prototype.ngOnDestroy = function () {
        MultiLingualData.remove(name);
        viewRefContainer.destroy(this);
        if (onDestroy)
            onDestroy.bind(this).call();
    };
}

const translateContainer = new (class {
    constructor() {
        this.store = new Array();
        this.additionalStore = new Array();
        this.componentState = {};
    }
    set(instance, config) {
        let translateConfig = this.store.filter(t => t.instance == instance)[0];
        if (!translateConfig)
            this.store.push({ instance: instance, config: config });
        else
            this.additionalStore.push({ instance: instance, config: config });
    }
    get(instance) {
        let containerConfig = this.store.filter(t => t.instance == instance);
        return containerConfig.length > 0 ? containerConfig[0] : undefined;
    }
    additionalGet(instance) {
        return this.additionalStore.filter(t => t.instance == instance);
    }
    getByName(name) {
        let containerConfig = this.store.filter(t => t.config.translationName == name);
        if (containerConfig.length == 0)
            containerConfig = this.additionalStore.filter(t => t.config.translationName == name);
        return containerConfig.length > 0 ? containerConfig[0] : undefined;
    }
    defineAsyncProperty(instance, propertyName, config) {
        let isPropertyKey = (propertyName != undefined);
        var model = !isPropertyKey ? instance : instance.constructor;
        defineAsyncProperty(model, propertyName, config);
    }
    defineProperty(instance, propertyName, config) {
        let isPropertyKey = (propertyName != undefined);
        var model = !isPropertyKey ? instance : instance.constructor;
        let modelName = config === undefined ? "global" : config.translationName;
        defineProperty(model, propertyName, modelName, config ? config.language : undefined, config ? config.filePath : undefined);
        if (modelName != "global" && propertyName) {
            let instanceConfig = { instance: model, config: config };
            this.set(model, config);
            let count = this.store.filter(t => t.instance == model).length;
            count = this.additionalStore.filter(t => t.instance == model).length + count;
            if (count == 1)
                overrideDestroyMethod(model, config.translationName);
            return instanceConfig;
        }
        else if (!propertyName)
            this.set(model, config);
    }
    setComponentState(key, instance) {
        this.componentState[key] = instance;
    }
    getComponentState(key) {
        return this.componentState[key];
    }
    getActiveTranslations() {
        return this.store;
    }
})();

function replacer(extractKeys, text, data) {
    if (text && text.indexOf("{{") != -1) {
        let extractor = extract(extractKeys);
        let keys = extractor(text);
        keys.forEach(key => {
            text = text.replace(`{{${key}}}`, getValue(key, data));
        });
    }
    return text;
}

class BaseResolver {
    constructor(baseConfig, httpClient) {
        this.baseConfig = baseConfig;
        this.httpClient = httpClient;
        this.cloneBaseConfig = Object.assign({}, baseConfig);
    }
    resolveGlobal(config, isGlobal = true) {
        if (isGlobal)
            translateContainer.set(config.instance, config.config);
        if ((isGlobal && !this.baseConfig.forNgxTranslate) || !isGlobal) {
            translateConfigContainer.globalTranslate = this.resolve(config);
            translateConfigContainer.globalTranslate.subscribe(t => {
                translateConfigContainer.globalTranslate = undefined;
            });
        }
    }
    resolve(config, languageCode = "", isRouteLanguageChanged = false) {
        let containerConfig = config;
        if ((containerConfig && this.cloneBaseConfig.isTest) || (containerConfig && !MultiLingualData.contains(getKeyName(containerConfig.config.translationName, languageCode || this.cloneBaseConfig.languageCode), languageCode || this.cloneBaseConfig.languageCode)) || (containerConfig && isRouteLanguageChanged)) {
            let lang = containerConfig.config.language || languageCode || this.cloneBaseConfig.languageCode;
            if (containerConfig.config.inlineTranslations && containerConfig.config.inlineTranslations[lang]) {
                return Observable.create((subcriber) => {
                    containerConfig.config.inlineTranslations[lang]().then(t => { subcriber.next(t.default); subcriber.complete(); });
                }).pipe(map(this.setData(lang, containerConfig).bind(this)));
            }
            else if (!translateConfigContainer.customLoader) {
                let url = this.getPath(containerConfig, languageCode);
                if (url)
                    return this.httpClient.get(url).pipe(map(this.setData(lang, containerConfig).bind(this)));
            }
            else {
                let translationObject = lang;
                if (config.config.translationName != "global")
                    translationObject = Object.assign(Object.assign({}, config.config), { filePath: this.getPath(containerConfig, languageCode), lang: lang });
                return translateConfigContainer.customLoader.getTranslation(translationObject).pipe(map(this.setData(lang, containerConfig).bind(this)));
            }
        }
        else if ((containerConfig && MultiLingualData.contains(getKeyName(containerConfig.config.translationName, languageCode || this.cloneBaseConfig.languageCode), languageCode || this.cloneBaseConfig.languageCode))) {
            let body = MultiLingualData.get(getKeyName(containerConfig.config.translationName, languageCode || this.cloneBaseConfig.languageCode));
            this.setTitle(body, containerConfig);
        }
        return of(true);
    }
    setTitle(body, containerConfig) {
        if (translateConfigContainer.activePageTranslationName == containerConfig.config.translationName)
            this.setPageTitle(body);
    }
    setData(languageCode, containerConfig) {
        return body => {
            let name = getKeyName(containerConfig.config.translationName, languageCode || this.cloneBaseConfig.languageCode, containerConfig.config.filePath);
            let data = body;
            if (translateConfigContainer.resolver)
                data = translateConfigContainer.resolver(name.replace("global_", "").replace("global", ""), data);
            MultiLingualData.addOrUpdate(name, data, containerConfig.config.translationName, this.cloneBaseConfig.languageCode);
            this.setTitle(body, containerConfig);
            setTimeout(() => { MultiLingualData.clearInActives(this.cloneBaseConfig); }, 10);
            return body;
        };
    }
    getPath(containerConfig, languageCode = "") {
        let url = '';
        let splitKeywords = ['{{', '}}'];
        languageCode = containerConfig.config.language || languageCode || this.cloneBaseConfig.languageCode;
        if (containerConfig.config.filePath || this.cloneBaseConfig.filePath) {
            if (containerConfig.config.filePath) {
                let text = replacer(splitKeywords, containerConfig.config.filePath, { "language-code": languageCode, "translation-name": containerConfig.config.translationName });
                url = `/${text}`;
            }
            else {
                let text = replacer(splitKeywords, this.cloneBaseConfig.filePath, { "language-code": languageCode, "translation-name": containerConfig.config.translationName });
                url = `/${text}`;
            }
        }
        return url;
    }
    resolveRoute(route) {
        if (route.component) {
            let isRouteLanguageChanged = route.params && route.params["languageCode"] && route.params["languageCode"] != this.cloneBaseConfig.languageCode;
            let containerConfig = translateContainer.get(route.component);
            if (isRouteLanguageChanged) {
                this.updateLanguageByParam(route);
                this.cloneBaseConfig.languageCode = route.params["languageCode"];
                translateConfigContainer.loading = true;
            }
            if (containerConfig) {
                if (containerConfig.config)
                    translateConfigContainer.activePageTranslationName = containerConfig.config.translationName;
                return this.resolveData(containerConfig, '', isRouteLanguageChanged);
            }
            else if (isRouteLanguageChanged && translateConfigContainer.ngxTranslate) {
                translateConfigContainer.ngxTranslate.use(route.params["languageCode"]);
                translateConfigContainer.loading = false;
            }
        }
        return of(true);
    }
    resolveData(containerConfig, languageCode, isRouteLanguageChanged = false) {
        let additionalContainerConfigs = translateContainer.additionalGet(containerConfig.instance);
        let observables = new Array();
        additionalContainerConfigs.forEach(config => {
            observables.push(this.resolve(config, languageCode, isRouteLanguageChanged));
        });
        observables.push(this.resolve(containerConfig, languageCode, isRouteLanguageChanged));
        return forkJoin(observables).pipe(map((response) => {
            this.baseConfig.languageCode = this.cloneBaseConfig.languageCode;
            translateConfigContainer.loading = false;
            if (isRouteLanguageChanged && translateConfigContainer.ngxTranslate)
                translateConfigContainer.ngxTranslate.use(this.baseConfig.languageCode);
            return true;
        }));
    }
    updateLanguageByParam(route) {
        if (route.params && route.params["languageCode"] && (!this.baseConfig.languageCode || this.baseConfig.languageCode !== route.params["languageCode"])) {
            setTimeout(() => this.languageChanged(route.params["languageCode"]), 10);
        }
    }
    languageChanged(languageCode, onComplete) {
        let keys = this.getKeys(this.baseConfig.languageCode);
        this.cloneBaseConfig.languageCode = languageCode;
        this.changeTranslation(keys, 0, onComplete);
    }
    resolveByName(name, languageCode = null) {
        let containerConfig = translateContainer.getByName(name);
        return this.resolve(containerConfig, languageCode);
    }
    fakeResolveByName(name, fakeData, resolve) {
    }
    getKeys(languageCode) {
        return MultiLingualData.getActiveKeys().map(key => {
            return key.replace(`_${languageCode}`, '');
        });
    }
    changeTranslation(keys, index, onComplete) {
        if (keys.length > index) {
            translateConfigContainer.loading = true;
            var baseResolver = new BaseResolver(this.cloneBaseConfig, this.httpClient);
            baseResolver.resolveByName(keys[index]).subscribe(x => {
                let nextIndex = index + 1;
                this.changeTranslation(keys, nextIndex, onComplete);
            });
        }
        else {
            translateConfigContainer.config.languageCode = this.cloneBaseConfig.languageCode;
            translateConfigContainer.loading = false;
            if (onComplete)
                onComplete();
        }
    }
    setPageTitle(body) {
        if (body && body["pageTitle"])
            document.title = body["pageTitle"];
    }
}

function translate(config) {
    return function (target, propertyKey, parameterIndex) {
        let instanceConfig = translateContainer.defineProperty(target, propertyKey, config);
        if (translateConfigContainer.config && translateConfigContainer.config.preloadingStrategy && instanceConfig != undefined) {
            var baseResolver = new BaseResolver(translateConfigContainer.config, translateConfigContainer.httpClient);
            baseResolver.resolveGlobal(instanceConfig, false);
        }
    };
}

function asyncTranslate(config) {
    return function (target, propertyKey, parameterIndex) {
        translateContainer.defineAsyncProperty(target, propertyKey, config);
    };
}

const TranslationCore = new (class {
    constructor() {
        this.languageChangedSubject = new Subject();
        this.languageChanged = this.languageChangedSubject.asObservable();
    }
    getText(path) {
        let splitText = path.split('.');
        let keyName = getKeyName(splitText[0]);
        let data = MultiLingualData.get(keyName);
        let text = '';
        if (data) {
            splitText.splice(0, 1);
            for (var col of splitText)
                text = text ? text[col] : data[col];
        }
        return text;
    }
});

class RxTranslation {
    constructor(httpClient, ref) {
        this.httpClient = httpClient;
        this.ref = ref;
    }
    get language() {
        return translateConfigContainer.config.languageCode;
    }
    change(languageCode, onComplete) {
        var baseResolver = new BaseResolver(translateConfigContainer.config, this.httpClient);
        baseResolver.languageChanged(languageCode, () => { viewRefContainer.markForCheck(); if (onComplete)
            onComplete(); TranslationCore.languageChangedSubject.next(true); });
    }
    translate(text, data) {
        let extractor = extract(['{', '}']);
        let keys = extractor(text);
        keys.forEach(key => {
            text = text.replace(`{${key}}`, getValue(key, data));
        });
        return text;
    }
}
RxTranslation.decorators = [
    { type: Injectable }
];
RxTranslation.ctorParameters = () => [
    { type: HttpClient },
    { type: ApplicationRef }
];

class RxTranslateConfig {
    constructor() {
        this.allowedLanguages = [];
    }
}

const RX_TRANSLATE_CONFIG = "rxTranslateConfig";
const CUSTOM_LOADER = "customLoader";

class ComponentGuard extends BaseResolver {
    constructor(config, injector, customLoader, httpClient) { super(config, httpClient); translateConfigContainer.injector = injector; if (!translateConfigContainer.customLoader)
        translateConfigContainer.customLoader = customLoader; }
    canActivateChild(childRoute, state) {
        return this.resolveGlobalTranslate(childRoute);
    }
    canActivate(route, state) {
        return this.resolveGlobalTranslate(route);
    }
    resolveGlobalTranslate(route) {
        this.cloneBaseConfig = Object.assign({}, translateConfigContainer.config);
        if (translateConfigContainer.globalTranslate) {
            return Observable.create(subscriber => {
                translateConfigContainer.globalTranslate.subscribe(t => {
                    this.resolveRoute(route).subscribe(x => { subscriber.next(x); subscriber.complete(); });
                });
            });
        }
        else
            return this.resolveRoute(route);
    }
}
ComponentGuard.decorators = [
    { type: Injectable }
];
ComponentGuard.ctorParameters = () => [
    { type: RxTranslateConfig, decorators: [{ type: Inject, args: [RX_TRANSLATE_CONFIG,] }] },
    { type: Injector },
    { type: undefined, decorators: [{ type: Inject, args: [CUSTOM_LOADER,] }] },
    { type: HttpClient }
];

class RxTranslateDirective {
    constructor(viewContainerRef, templateRef, injector, baseConfig, route, httpClient) {
        this.viewContainerRef = viewContainerRef;
        this.templateRef = templateRef;
        this.injector = injector;
        this.route = route;
        this.httpClient = httpClient;
        this.viewRef = null;
        this._context = new NgIfContext();
        let ref = this.templateRef;
        this.baseConfig = translateConfigContainer.config.forNgxTranslate ? translateConfigContainer.config : baseConfig;
        let elementName = null;
        if (ref._def) {
            elementName = ref._def.element.template.nodes[0].element.name;
            let node = ref._def.element.template.nodes[ref._def.element.template.nodes.length - 1];
            this.component = node.provider.token;
            this.config = translateContainer.get(node.provider.token);
        }
        else if (ref._declarationTContainer) {
            let tagName = ref._declarationTContainer.tagName;
            elementName = tagName.toLowerCase();
            let tView = ref._declarationTContainer.tView_ || ref._declarationTContainer.tViews;
            let node = tView.directiveRegistry.filter(t => t.selectors.filter(y => y == tagName)[0] != undefined)[0];
            if (node) {
                this.config = translateContainer.get(node.type);
                this.component = node.type;
            }
        }
        if (baseConfig.forNgxTranslate && this.component && elementName)
            translateContainer.setComponentState(elementName, this.component);
    }
    set translate(value) {
        if (this.config) {
            let baseResolver = new BaseResolver(this.baseConfig, this.httpClient);
            let languageCode = "";
            if (this.route.params && this.route.params["languageCode"] && this.baseConfig.languageCode !== this.route.params["languageCode"] && !this.config.config.language)
                languageCode = this.route.params["languageCode"];
            this.subscription = baseResolver.resolveData(this.config, languageCode).subscribe(x => {
                this.updateView(x);
            });
        }
        else
            this.updateView(true);
    }
    updateView(value) {
        if (this.viewRef) {
            this.viewContainerRef.clear();
            this.viewRef = null;
        }
        if (value)
            this.viewRef = this.viewContainerRef.createEmbeddedView(this.templateRef, this._context);
        else
            this.viewContainerRef.clear();
    }
    ngOnDestroy() {
        if (this.subscription)
            this.subscription.unsubscribe();
        viewRefContainer.destroy(this.component);
    }
}
RxTranslateDirective.decorators = [
    { type: Directive, args: [{
                selector: '[rxTranslate]'
            },] }
];
RxTranslateDirective.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: TemplateRef },
    { type: Injector },
    { type: RxTranslateConfig, decorators: [{ type: Inject, args: [RX_TRANSLATE_CONFIG,] }] },
    { type: ActivatedRoute },
    { type: HttpClient }
];
RxTranslateDirective.propDecorators = {
    translate: [{ type: Input, args: ['rxTranslate',] }]
};

function overrideProperty() {
    Object.defineProperty(ActivatedRouteSnapshot.prototype, "routeConfig", {
        get: function () { return this.cloneSnap; },
        set: function (v) {
            this.cloneSnap = v;
            if (this.cloneSnap && !this.cloneSnap.canActivate) {
                this.cloneSnap.canActivate = [ComponentGuard];
            }
            else if (this.cloneSnap && this.cloneSnap.canActivate) {
                if (this.cloneSnap.canActivate.filter(t => t == ComponentGuard).length == 0) {
                    this.cloneSnap.canActivate.push(ComponentGuard);
                }
            }
            if (this.cloneSnap && this.cloneSnap.children) {
                if (this.cloneSnap && !this.cloneSnap.canActivateChild) {
                    this.cloneSnap.canActivateChild = [ComponentGuard];
                }
                else if (this.cloneSnap && this.cloneSnap.canActivateChild) {
                    if (this.cloneSnap.canActivateChild.filter(t => t == ComponentGuard).length == 0)
                        this.cloneSnap.canActivateChild.push(ComponentGuard);
                }
            }
        },
        enumerable: true,
        configurable: true
    });
}

const NOT_IN = ["min", "max"];
function overrideErrorsProperty(errorMessageConfig) {
    let language = translateConfigContainer.config.languageCode;
    Object.defineProperty(AbstractControl.prototype, "errors", {
        get: function () {
            if (this.originalErrors && this.originalErrors.languageCode != translateConfigContainer.config.languageCode) {
                this.cloneErrors = getTranslatedErrorMessages(errorMessageConfig, Object.assign({}, this.originalErrors), this.value);
            }
            return this.cloneErrors;
        },
        set: function (v) {
            this.originalErrors = v;
            this.cloneErrors = v;
            if (v && isObject(v))
                this.cloneErrors = getTranslatedErrorMessages(errorMessageConfig, Object.assign({}, v), this.value);
        },
        enumerable: true,
        configurable: true
    });
}
function getTranslatedErrorMessages(errorMessageConfig, errors, value) {
    let keyName = getKeyName("global");
    let data = MultiLingualData.get(keyName);
    if (data) {
        data = errorMessageConfig.path == "" ? data : getValue(errorMessageConfig.path, data);
        if (errors && isObject(errors)) {
            Object.keys(errors).forEach(key => {
                if (errors[key]) {
                    let message = '';
                    if (data[key])
                        message = getMessage(data, key);
                    if (message) {
                        Object.keys(errors[key]).forEach(t => {
                            if (Array.isArray(errors[key][t])) {
                                errors[key][t].forEach((x, i) => {
                                    message = message.replace(`{{${i}}}`, errors[key][t][i]);
                                });
                            }
                            else
                                message = message.replace(`{{${t}}}`, errors[key][t]);
                        });
                        value = value ? value : '';
                        message = message.replace(`{{value}}`, value);
                    }
                    if (!isObject(errors[key]))
                        errors[key] = {};
                    errors[key]["message"] = message;
                }
            });
            errors["languageCode"] = translateConfigContainer.config.languageCode;
        }
    }
    return errors;
}
function getMessage(data, key) {
    let text = data[key];
    if (text.indexOf('{{') !== -1) {
        let stringExtractor = extract(['{{', '}}']);
        let keys = stringExtractor(text);
        keys.forEach(key => {
            let value = runPipe(key, data, data);
            if (key == value && NOT_IN.indexOf(key) == -1) {
                value = getValue(key, data);
                if (value) {
                    text = text.replace(`{{${key}}}`, value);
                }
            }
        });
    }
    return text;
}

class TranslationResolver {
    constructor(httpClient) {
        this.httpClient = httpClient;
        this._allowedLanguages = [];
    }
    set controlErrorMessage(value) {
        if (translateConfigContainer.config && !translateConfigContainer.config.controlErrorMessage) {
            translateConfigContainer.config.controlErrorMessage = value;
            overrideErrorsProperty(translateConfigContainer.config.controlErrorMessage);
        }
    }
    set resolver(value) {
        translateConfigContainer.resolver = value;
    }
    get allowedLanguages() {
        return this._allowedLanguages;
    }
    get activeTranslationsLength() {
        return translateContainer.getActiveTranslations().length;
    }
    set ngxTranslate(value) {
        translateConfigContainer.ngxTranslate = value;
        translateConfigContainer.customLoader = value.customLoader;
    }
    get injector() {
        return translateConfigContainer.injector;
    }
    get pending() {
        return translateConfigContainer.loading;
    }
    get activeLanguage() {
        return translateConfigContainer.config.languageCode;
    }
    set activeLanguage(lang) {
        translateConfigContainer.config.languageCode = lang;
    }
    get translations() {
        return MultiLingualData.data;
    }
    getTranslationName(nodeName, languageCode = null) {
        let instance = translateContainer.getComponentState(nodeName);
        if (instance) {
            let translateConfig = translateContainer.get(instance);
            if (translateConfig && translateConfig.config)
                return getKeyName(translateConfig.config.translationName, languageCode);
        }
        return null;
    }
    getTranslationNameByInstance(instance, languageCode = null) {
        let translateConfig = translateContainer.get(instance);
        if (translateConfig && translateConfig.config)
            return getKeyName(translateConfig.config.translationName, languageCode);
        return null;
    }
    get(modelName, languageCode = '') {
        return MultiLingualData.get(this.getKeyName(modelName, languageCode));
    }
    getKeyName(modelName, languageCode = '') {
        return getKeyName(modelName, languageCode);
    }
    resolve(modelName, languageCode) {
        var baseResolver = new BaseResolver(translateConfigContainer.config, this.httpClient);
        return baseResolver.resolveByName(modelName, languageCode);
    }
    addConfig(name) {
        let containerConfig = translateContainer.getByName(name);
        if (!containerConfig)
            translateContainer.set(null, { translationName: name });
    }
}
TranslationResolver.decorators = [
    { type: Injectable }
];
TranslationResolver.ctorParameters = () => [
    { type: HttpClient }
];

class RxTranslatePipe {
    transform(text, params) {
        if (text && params && Object.keys(params).length > 0) {
            if (text.indexOf('{{{this') !== -1) {
                let stringExtractor = extract(['{{{', '}}}']);
                let keys = stringExtractor(text);
                keys.forEach(t => {
                    var func = new Function("x", "return " + t);
                    let calculatedText = func.call(params);
                    text = text.replace(`{{{${t}}}}`, calculatedText);
                });
            }
            if (text && text.indexOf("{{") != -1) {
                let stringExtractor = extract(['{{', '}}']);
                let keys = stringExtractor(text);
                keys.forEach(key => {
                    let value = getValue(key, params);
                    text = text.replace(`{{${key}}}`, value);
                });
            }
        }
        return text;
    }
}
RxTranslatePipe.decorators = [
    { type: Pipe, args: [{ name: 'rxTranslate' },] }
];

class RxTranslateModule {
    constructor(config, httpClient) {
        if (!translateConfigContainer.config) {
            translateConfigContainer.httpClient = httpClient;
            translateConfigContainer.config = config;
            if (!translateConfigContainer.config.languageCode)
                translateConfigContainer.config.languageCode = "en";
            let translateConfig = { config: { translationName: 'global', filePath: config.globalFilePath }, instance: null };
            var baseResolver = new BaseResolver(config, httpClient);
            baseResolver.resolveGlobal(translateConfig);
            overrideProperty();
            if (config.controlErrorMessage)
                overrideErrorsProperty(config.controlErrorMessage);
        }
    }
    static forRoot(config) {
        return {
            ngModule: RxTranslateModule,
            providers: [
                ComponentGuard, RxTranslation,
                { provide: RX_TRANSLATE_CONFIG, useValue: config },
                config.loader ? { provide: CUSTOM_LOADER, useClass: config.loader } : { provide: CUSTOM_LOADER, useValue: null },
            ]
        };
    }
}
RxTranslateModule.decorators = [
    { type: NgModule, args: [{
                imports: [RouterModule, HttpClientModule],
                declarations: [RxTranslateDirective, RxTranslatePipe],
                providers: [ComponentGuard, RxTranslation, TranslationResolver, { provide: CUSTOM_LOADER, useValue: null }],
                exports: [RxTranslateDirective, RxTranslatePipe],
            },] }
];
RxTranslateModule.ctorParameters = () => [
    { type: RxTranslateConfig, decorators: [{ type: Inject, args: [RX_TRANSLATE_CONFIG,] }] },
    { type: HttpClient }
];

class RxTranslateSanitizeModule {
}
RxTranslateSanitizeModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                providers: [CurrencyPipe, DatePipe, DecimalPipe, I18nPluralPipe, I18nSelectPipe, LowerCasePipe, PercentPipe, SlicePipe, TitleCasePipe, UpperCasePipe],
            },] }
];

function sanitize(config) {
    return function (target) {
        PIPE_CONFIG[config.name] = target;
    };
}

/**
 * Generated bundle index. Do not edit.
 */

export { RxTranslateModule, RxTranslatePipe, RxTranslateSanitizeModule, RxTranslation, TranslationCore, TranslationResolver, asyncTranslate, equals, replacer, sanitize, translate, RxTranslateDirective as ɵa, RX_TRANSLATE_CONFIG as ɵb, CUSTOM_LOADER as ɵc, RxTranslateConfig as ɵd, ComponentGuard as ɵe, BaseResolver as ɵf };
//# sourceMappingURL=rxweb-translate.js.map
